{"version":3,"file":"maps-legacy-DLWhc_uQ.js","sources":["../../src/providers/google/maps.ts","../../src/lib/telemetry/index.ts","../../src/types/index.ts"],"sourcesContent":["import type { \n  PlacesProvider, \n  RoutingProvider, \n  Place, \n  PlaceDetail, \n  PhotoRef, \n  Route, \n  LatLng \n} from '@/types';\nimport { AppError } from '@/types';\nimport { telemetry } from '@/lib/telemetry';\n\ninterface GoogleMapsConfig {\n  apiKey: string;\n  language?: string;\n  region?: string;\n}\n\n// Google Maps Places Provider\nexport class GooglePlacesProvider implements PlacesProvider {\n  private config: GoogleMapsConfig;\n  private service?: google.maps.places.PlacesService;\n\n  constructor(config: GoogleMapsConfig) {\n    this.config = config;\n    this.initializeService();\n  }\n\n  private async initializeService(): Promise<void> {\n    if (this.service) return;\n\n    // Load Google Maps JavaScript API if not already loaded\n    if (typeof google === 'undefined') {\n      await this.loadGoogleMapsAPI();\n    }\n\n    // Create a temporary div for PlacesService\n    const div = document.createElement('div');\n    this.service = new google.maps.places.PlacesService(div);\n  }\n\n  private loadGoogleMapsAPI(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (typeof google !== 'undefined') {\n        resolve();\n        return;\n      }\n\n      const script = document.createElement('script');\n      script.src = `https://maps.googleapis.com/maps/api/js?key=${this.config.apiKey}&libraries=places&language=${this.config.language || 'en'}`;\n      script.async = true;\n      script.defer = true;\n      \n      script.onload = () => resolve();\n      script.onerror = () => reject(new AppError('Failed to load Google Maps API', 'MAPS_API_LOAD_FAILED'));\n      \n      document.head.appendChild(script);\n    });\n  }\n\n  async search(\n    query: string, \n    options: {\n      near?: LatLng;\n      type?: string;\n      openNow?: boolean;\n      radius?: number;\n    } = {}\n  ): Promise<Place[]> {\n    const startTime = performance.now();\n    \n    try {\n      await this.initializeService();\n      \n      const request: google.maps.places.TextSearchRequest = {\n        query,\n        location: options.near ? new google.maps.LatLng(options.near.lat, options.near.lng) : undefined,\n        radius: options.radius || 5000,\n        type: options.type as any,\n        openNow: options.openNow\n      };\n\n      const results = await new Promise<google.maps.places.PlaceResult[]>((resolve, reject) => {\n        this.service!.textSearch(request, (results, status) => {\n          if (status === google.maps.places.PlacesServiceStatus.OK && results) {\n            resolve(results);\n          } else {\n            reject(new AppError(`Places search failed: ${status}`, 'PLACES_SEARCH_FAILED'));\n          }\n        });\n      });\n\n      const places = results.map(this.transformPlace).filter(Boolean) as Place[];\n      \n      telemetry.track('places_search', {\n        query,\n        results_count: places.length,\n        duration: performance.now() - startTime,\n        has_location: !!options.near\n      });\n\n      return places;\n    } catch (error) {\n      telemetry.track('places_search_error', {\n        query,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        duration: performance.now() - startTime\n      });\n      throw error;\n    }\n  }\n\n  async details(placeId: string): Promise<PlaceDetail> {\n    const startTime = performance.now();\n    \n    try {\n      await this.initializeService();\n\n      const request: google.maps.places.PlaceDetailsRequest = {\n        placeId,\n        fields: [\n          'place_id', 'name', 'formatted_address', 'geometry',\n          'rating', 'user_ratings_total', 'price_level', 'types',\n          'opening_hours', 'formatted_phone_number', 'website',\n          'reviews', 'photos', 'vicinity'\n        ]\n      };\n\n      const result = await new Promise<google.maps.places.PlaceResult>((resolve, reject) => {\n        this.service!.getDetails(request, (place, status) => {\n          if (status === google.maps.places.PlacesServiceStatus.OK && place) {\n            resolve(place);\n          } else {\n            reject(new AppError(`Place details failed: ${status}`, 'PLACE_DETAILS_FAILED'));\n          }\n        });\n      });\n\n      const placeDetail = this.transformPlaceDetail(result);\n      \n      telemetry.track('place_details', {\n        place_id: placeId,\n        duration: performance.now() - startTime\n      });\n\n      return placeDetail;\n    } catch (error) {\n      telemetry.track('place_details_error', {\n        place_id: placeId,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        duration: performance.now() - startTime\n      });\n      throw error;\n    }\n  }\n\n  async photos(placeId: string, maxPhotos = 5): Promise<PhotoRef[]> {\n    try {\n      const placeDetail = await this.details(placeId);\n      return placeDetail.photos?.slice(0, maxPhotos) || [];\n    } catch (error) {\n      console.warn('Failed to get place photos:', error);\n      return [];\n    }\n  }\n\n  private transformPlace(gPlace: google.maps.places.PlaceResult): Place | null {\n    if (!gPlace.place_id || !gPlace.name || !gPlace.geometry?.location) {\n      return null;\n    }\n\n    return {\n      id: gPlace.place_id,\n      name: gPlace.name,\n      address: gPlace.formatted_address,\n      location: {\n        lat: gPlace.geometry.location.lat(),\n        lng: gPlace.geometry.location.lng()\n      },\n      rating: gPlace.rating,\n      userRatingsTotal: gPlace.user_ratings_total,\n      priceLevel: gPlace.price_level,\n      types: gPlace.types,\n      openNow: gPlace.opening_hours?.open_now,\n      photos: gPlace.photos?.map(photo => ({\n        url: photo.getUrl({ maxWidth: 400, maxHeight: 300 }),\n        width: 400,\n        height: 300,\n        attributions: photo.html_attributions\n      }))\n    };\n  }\n\n  private transformPlaceDetail(gPlace: google.maps.places.PlaceResult): PlaceDetail {\n    const base = this.transformPlace(gPlace);\n    if (!base) {\n      throw new AppError('Invalid place data', 'INVALID_PLACE_DATA');\n    }\n\n    return {\n      ...base,\n      formattedAddress: gPlace.formatted_address || base.address || '',\n      phoneNumber: gPlace.formatted_phone_number,\n      website: gPlace.website,\n      openingHours: gPlace.opening_hours ? {\n        openNow: gPlace.opening_hours.open_now || false,\n        periods: gPlace.opening_hours.periods?.map(period => ({\n          open: {\n            day: period.open?.day || 0,\n            time: period.open?.time || '0000'\n          },\n          close: period.close ? {\n            day: period.close.day,\n            time: period.close.time\n          } : undefined\n        })) || [],\n        weekdayText: gPlace.opening_hours.weekday_text || []\n      } : undefined,\n      reviews: gPlace.reviews?.map(review => ({\n        author: review.author_name,\n        rating: review.rating,\n        text: review.text,\n        time: review.time\n      })),\n      vicinity: gPlace.vicinity\n    };\n  }\n}\n\n// Google Routes Provider\nexport class GoogleRoutesProvider implements RoutingProvider {\n  private config: GoogleMapsConfig;\n  private service?: google.maps.DirectionsService;\n\n  constructor(config: GoogleMapsConfig) {\n    this.config = config;\n    this.initializeService();\n  }\n\n  private async initializeService(): Promise<void> {\n    if (this.service) return;\n\n    if (typeof google === 'undefined') {\n      await this.loadGoogleMapsAPI();\n    }\n\n    this.service = new google.maps.DirectionsService();\n  }\n\n  private loadGoogleMapsAPI(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (typeof google !== 'undefined') {\n        resolve();\n        return;\n      }\n\n      const script = document.createElement('script');\n      script.src = `https://maps.googleapis.com/maps/api/js?key=${this.config.apiKey}&language=${this.config.language || 'en'}`;\n      script.async = true;\n      script.defer = true;\n      \n      script.onload = () => resolve();\n      script.onerror = () => reject(new AppError('Failed to load Google Maps API', 'MAPS_API_LOAD_FAILED'));\n      \n      document.head.appendChild(script);\n    });\n  }\n\n  async route(input: {\n    origin: LatLng;\n    destination: LatLng;\n    via?: LatLng[];\n    mode?: 'car' | 'bike' | 'walk';\n    avoidTolls?: boolean;\n    departTime?: Date;\n  }): Promise<Route> {\n    const startTime = performance.now();\n    \n    try {\n      await this.initializeService();\n\n      const request: google.maps.DirectionsRequest = {\n        origin: new google.maps.LatLng(input.origin.lat, input.origin.lng),\n        destination: new google.maps.LatLng(input.destination.lat, input.destination.lng),\n        waypoints: input.via?.map(point => ({\n          location: new google.maps.LatLng(point.lat, point.lng),\n          stopover: true\n        })),\n        travelMode: this.getTravelMode(input.mode || 'car'),\n        avoidTolls: input.avoidTolls || false,\n        drivingOptions: input.departTime ? {\n          departureTime: input.departTime,\n          trafficModel: google.maps.TrafficModel.BEST_GUESS\n        } : undefined,\n        unitSystem: google.maps.UnitSystem.METRIC\n      };\n\n      const result = await new Promise<google.maps.DirectionsResult>((resolve, reject) => {\n        this.service!.route(request, (result, status) => {\n          if (status === google.maps.DirectionsStatus.OK && result) {\n            resolve(result);\n          } else {\n            reject(new AppError(`Route calculation failed: ${status}`, 'ROUTE_CALCULATION_FAILED'));\n          }\n        });\n      });\n\n      const route = this.transformRoute(result);\n      \n      telemetry.track('route_calculation', {\n        mode: input.mode,\n        has_waypoints: !!(input.via?.length),\n        duration: performance.now() - startTime,\n        distance: route.overview.distance,\n        travel_time: route.overview.duration\n      });\n\n      return route;\n    } catch (error) {\n      telemetry.track('route_calculation_error', {\n        mode: input.mode,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        duration: performance.now() - startTime\n      });\n      throw error;\n    }\n  }\n\n  private getTravelMode(mode: string): google.maps.TravelMode {\n    switch (mode) {\n      case 'walk': return google.maps.TravelMode.WALKING;\n      case 'bike': return google.maps.TravelMode.BICYCLING;\n      case 'transit': return google.maps.TravelMode.TRANSIT;\n      default: return google.maps.TravelMode.DRIVING;\n    }\n  }\n\n  private transformRoute(gRoute: google.maps.DirectionsResult): Route {\n    const route = gRoute.routes[0];\n    if (!route) {\n      throw new AppError('No route found', 'NO_ROUTE_FOUND');\n    }\n\n    return {\n      legs: route.legs.map(leg => ({\n        start: {\n          lat: leg.start_location.lat(),\n          lng: leg.start_location.lng()\n        },\n        end: {\n          lat: leg.end_location.lat(),\n          lng: leg.end_location.lng()\n        },\n        duration: leg.duration?.value || 0,\n        distance: leg.distance?.value || 0,\n        steps: leg.steps.map(step => ({\n          instruction: step.instructions,\n          duration: step.duration?.value || 0,\n          distance: step.distance?.value || 0,\n          start: {\n            lat: step.start_location.lat(),\n            lng: step.start_location.lng()\n          },\n          end: {\n            lat: step.end_location.lat(),\n            lng: step.end_location.lng()\n          },\n          polyline: step.polyline?.points || '',\n          maneuver: step.maneuver\n        })),\n        polyline: leg.steps.map(step => step.polyline?.points).join('')\n      })),\n      overview: {\n        polyline: route.overview_polyline?.points || '',\n        bounds: {\n          north: route.bounds?.getNorthEast().lat() || 0,\n          south: route.bounds?.getSouthWest().lat() || 0,\n          east: route.bounds?.getNorthEast().lng() || 0,\n          west: route.bounds?.getSouthWest().lng() || 0\n        },\n        duration: route.legs.reduce((sum, leg) => sum + (leg.duration?.value || 0), 0),\n        distance: route.legs.reduce((sum, leg) => sum + (leg.distance?.value || 0), 0)\n      },\n      warnings: route.warnings,\n      summary: route.summary\n    };\n  }\n}\n\n// Factory function to create providers\nexport function createGoogleProviders(apiKey: string) {\n  const config = { apiKey, language: 'en', region: 'US' };\n  \n  return {\n    places: new GooglePlacesProvider(config),\n    routing: new GoogleRoutesProvider(config)\n  };\n}","import type { TelemetryEvent, PerformanceMetric } from '@/types';\n\ninterface TelemetryConfig {\n  enabled: boolean;\n  endpoint?: string;\n  sessionId?: string;\n  userId?: string;\n  apiKey?: string;\n  batchSize?: number;\n  flushInterval?: number;\n}\n\nclass TelemetryManager {\n  private config: TelemetryConfig;\n  private eventQueue: TelemetryEvent[] = [];\n  private perfQueue: PerformanceMetric[] = [];\n  private flushTimer?: number;\n  private sessionId: string;\n\n  constructor(config: Partial<TelemetryConfig> = {}) {\n    this.config = {\n      enabled: import.meta.env.VITE_TELEMETRY_ENABLED === 'true',\n      endpoint: import.meta.env.VITE_TELEMETRY_ENDPOINT || '/api/telemetry',\n      batchSize: 10,\n      flushInterval: 30000, // 30 seconds\n      ...config\n    };\n\n    this.sessionId = this.generateSessionId();\n    \n    if (this.config.enabled) {\n      this.startPeriodicFlush();\n      this.setupUnloadHandler();\n      this.trackPageView();\n    }\n  }\n\n  track(eventName: string, properties?: Record<string, any>): void {\n    if (!this.config.enabled) return;\n\n    const event: TelemetryEvent = {\n      name: eventName,\n      properties: {\n        ...properties,\n        userAgent: navigator.userAgent,\n        url: window.location.href,\n        referrer: document.referrer\n      },\n      timestamp: Date.now(),\n      sessionId: this.sessionId,\n      userId: this.config.userId\n    };\n\n    this.eventQueue.push(event);\n    this.checkFlushThreshold();\n  }\n\n  trackPerformance(name: string, value: number, unit?: string): void {\n    if (!this.config.enabled) return;\n\n    const metric: PerformanceMetric = {\n      name,\n      value,\n      unit,\n      timestamp: Date.now()\n    };\n\n    this.perfQueue.push(metric);\n    this.checkFlushThreshold();\n  }\n\n  trackError(error: Error, context?: Record<string, any>): void {\n    if (!this.config.enabled) return;\n\n    this.track('error', {\n      message: error.message,\n      stack: error.stack,\n      name: error.name,\n      ...context\n    });\n  }\n\n  trackUserAction(action: string, target?: string, properties?: Record<string, any>): void {\n    if (!this.config.enabled) return;\n\n    this.track('user_action', {\n      action,\n      target,\n      ...properties\n    });\n  }\n\n  trackPageView(path?: string): void {\n    if (!this.config.enabled) return;\n\n    this.track('page_view', {\n      path: path || window.location.pathname,\n      title: document.title\n    });\n  }\n\n  measureTime<T>(name: string, fn: () => T | Promise<T>): T | Promise<T> {\n    if (!this.config.enabled) return fn();\n\n    const start = performance.now();\n    const result = fn();\n\n    if (result instanceof Promise) {\n      return result.finally(() => {\n        this.trackPerformance(name, performance.now() - start, 'ms');\n      }) as Promise<T>;\n    } else {\n      this.trackPerformance(name, performance.now() - start, 'ms');\n      return result;\n    }\n  }\n\n  setUser(userId: string): void {\n    this.config.userId = userId;\n  }\n\n  setProperty(key: string, value: any): void {\n    // Set global property for all future events\n    if (!(globalThis as any).__telemetryGlobals) {\n      (globalThis as any).__telemetryGlobals = {};\n    }\n    (globalThis as any).__telemetryGlobals[key] = value;\n  }\n\n  private generateSessionId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private startPeriodicFlush(): void {\n    this.flushTimer = window.setInterval(() => {\n      this.flush();\n    }, this.config.flushInterval);\n  }\n\n  private setupUnloadHandler(): void {\n    const handleUnload = () => {\n      this.flush(true); // Synchronous flush on unload\n    };\n\n    window.addEventListener('beforeunload', handleUnload);\n    window.addEventListener('visibilitychange', () => {\n      if (document.visibilityState === 'hidden') {\n        this.flush();\n      }\n    });\n  }\n\n  private checkFlushThreshold(): void {\n    const totalEvents = this.eventQueue.length + this.perfQueue.length;\n    if (totalEvents >= this.config.batchSize!) {\n      this.flush();\n    }\n  }\n\n  private async flush(synchronous = false): Promise<void> {\n    if (this.eventQueue.length === 0 && this.perfQueue.length === 0) {\n      return;\n    }\n\n    const events = [...this.eventQueue];\n    const metrics = [...this.perfQueue];\n    \n    // Clear queues\n    this.eventQueue = [];\n    this.perfQueue = [];\n\n    const payload = {\n      events: events.map(event => ({\n        ...event,\n        properties: {\n          ...event.properties,\n          ...(globalThis as any).__telemetryGlobals\n        }\n      })),\n      metrics,\n      sessionId: this.sessionId,\n      timestamp: Date.now()\n    };\n\n    try {\n      if (synchronous && 'sendBeacon' in navigator) {\n        // Use sendBeacon for reliable delivery during page unload\n        navigator.sendBeacon(\n          this.config.endpoint!,\n          JSON.stringify(payload)\n        );\n      } else {\n        await fetch(this.config.endpoint!, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...(this.config.apiKey && { 'Authorization': `Bearer ${this.config.apiKey}` })\n          },\n          body: JSON.stringify(payload),\n          keepalive: true\n        });\n      }\n    } catch (error) {\n      console.warn('Failed to send telemetry:', error);\n      // Re-queue events on failure (but limit to prevent infinite growth)\n      if (this.eventQueue.length < 100) {\n        this.eventQueue.unshift(...events.slice(-50));\n        this.perfQueue.unshift(...metrics.slice(-50));\n      }\n    }\n  }\n\n  destroy(): void {\n    if (this.flushTimer) {\n      clearInterval(this.flushTimer);\n    }\n    this.flush(true);\n  }\n}\n\n// Core Web Vitals tracking\nfunction trackWebVitals(): void {\n  if (!('PerformanceObserver' in window)) return;\n\n  try {\n    // Largest Contentful Paint\n    const lcpObserver = new PerformanceObserver((list) => {\n      const entries = list.getEntries();\n      const lastEntry = entries[entries.length - 1] as any;\n      if (lastEntry) {\n        telemetry.trackPerformance('lcp', lastEntry.startTime, 'ms');\n      }\n    });\n    lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });\n\n    // First Input Delay\n    const fidObserver = new PerformanceObserver((list) => {\n      const entries = list.getEntries();\n      entries.forEach((entry: any) => {\n        telemetry.trackPerformance('fid', entry.processingStart - entry.startTime, 'ms');\n      });\n    });\n    fidObserver.observe({ entryTypes: ['first-input'] });\n\n    // Cumulative Layout Shift\n    let clsValue = 0;\n    const clsObserver = new PerformanceObserver((list) => {\n      const entries = list.getEntries();\n      entries.forEach((entry: any) => {\n        if (!entry.hadRecentInput) {\n          clsValue += entry.value;\n        }\n      });\n    });\n    clsObserver.observe({ entryTypes: ['layout-shift'] });\n\n    // Send CLS on page hide\n    window.addEventListener('beforeunload', () => {\n      telemetry.trackPerformance('cls', clsValue);\n    });\n  } catch (error) {\n    console.warn('Web Vitals tracking failed:', error);\n  }\n}\n\n// Global telemetry instance\nexport const telemetry = new TelemetryManager();\n\n// Initialize Web Vitals tracking\nif (typeof window !== 'undefined') {\n  trackWebVitals();\n}\n\n// Export hook for easier usage\nexport function useTelemetry() {\n  return {\n    track: telemetry.track.bind(telemetry),\n    trackPerformance: telemetry.trackPerformance.bind(telemetry),\n    trackError: telemetry.trackError.bind(telemetry),\n    trackUserAction: telemetry.trackUserAction.bind(telemetry),\n    measureTime: telemetry.measureTime.bind(telemetry),\n    setUser: telemetry.setUser.bind(telemetry),\n    setProperty: telemetry.setProperty.bind(telemetry)\n  };\n}","// Core Types\nexport interface LatLng {\n  lat: number;\n  lng: number;\n}\n\nexport interface Bounds {\n  north: number;\n  south: number;\n  east: number;\n  west: number;\n}\n\n// Theme Types\nexport type Theme = 'light' | 'dark' | 'system';\n\nexport interface ThemeColors {\n  primary: string;\n  secondary: string;\n  background: string;\n  surface: string;\n  text: string;\n  textSecondary: string;\n  border: string;\n  success: string;\n  warning: string;\n  error: string;\n}\n\n// Place Types\nexport interface Place {\n  id: string;\n  name: string;\n  address?: string;\n  location: LatLng;\n  rating?: number;\n  userRatingsTotal?: number;\n  priceLevel?: number;\n  types?: string[];\n  openNow?: boolean;\n  photos?: PhotoRef[];\n  website?: string;\n  phoneNumber?: string;\n}\n\nexport interface PlaceDetail extends Place {\n  formattedAddress: string;\n  openingHours?: {\n    openNow: boolean;\n    periods: OpeningPeriod[];\n    weekdayText: string[];\n  };\n  reviews?: Review[];\n  vicinity?: string;\n}\n\nexport interface PhotoRef {\n  url: string;\n  width: number;\n  height: number;\n  attributions?: string[];\n}\n\nexport interface OpeningPeriod {\n  open: { day: number; time: string };\n  close?: { day: number; time: string };\n}\n\nexport interface Review {\n  author: string;\n  rating: number;\n  text: string;\n  time: number;\n}\n\n// Route Types\nexport interface Route {\n  legs: RouteLeg[];\n  overview: {\n    polyline: string;\n    bounds: Bounds;\n    duration: number;\n    distance: number;\n  };\n  warnings?: string[];\n  summary?: string;\n}\n\nexport interface RouteLeg {\n  start: LatLng;\n  end: LatLng;\n  duration: number;\n  distance: number;\n  steps: RouteStep[];\n  polyline: string;\n}\n\nexport interface RouteStep {\n  instruction: string;\n  duration: number;\n  distance: number;\n  start: LatLng;\n  end: LatLng;\n  polyline: string;\n  maneuver?: string;\n}\n\n// Weather Types\nexport interface WeatherNow {\n  temperature: number;\n  feelsLike: number;\n  humidity: number;\n  pressure: number;\n  visibility: number;\n  windSpeed: number;\n  windDirection: number;\n  precipitation: number;\n  cloudCover: number;\n  uvIndex: number;\n  condition: string;\n  icon: string;\n  isDaylight: boolean;\n}\n\nexport interface WeatherForecast {\n  hourly: WeatherHour[];\n  daily: WeatherDay[];\n}\n\nexport interface WeatherHour {\n  time: Date;\n  temperature: number;\n  precipitation: number;\n  windSpeed: number;\n  condition: string;\n  icon: string;\n}\n\nexport interface WeatherDay {\n  date: Date;\n  temperatureMax: number;\n  temperatureMin: number;\n  precipitation: number;\n  precipitationProbability: number;\n  windSpeed: number;\n  condition: string;\n  icon: string;\n  sunrise: Date;\n  sunset: Date;\n}\n\n// Trip Planning Types\nexport interface TripPlan {\n  id: string;\n  name: string;\n  description?: string;\n  startDate: Date;\n  endDate: Date;\n  stops: TripStop[];\n  route?: Route;\n  metadata: {\n    created: Date;\n    updated: Date;\n    version: number;\n  };\n}\n\nexport interface TripStop {\n  id: string;\n  place: Place;\n  arrivalTime?: Date;\n  departureTime?: Date;\n  duration?: number; // minutes\n  notes?: string;\n  category: StopCategory;\n  priority: number; // 1-5\n  weatherDependent?: boolean;\n}\n\nexport type StopCategory = \n  | 'meal'\n  | 'scenic'\n  | 'activity'\n  | 'accommodation'\n  | 'fuel'\n  | 'shopping'\n  | 'cultural'\n  | 'other';\n\n// AI Types\nexport interface PlanningConstraints {\n  maxDrivingTime?: number; // minutes\n  budget?: { min: number; max: number };\n  categories?: StopCategory[];\n  avoidTolls?: boolean;\n  weatherAware?: boolean;\n  accessibility?: boolean;\n  groupSize?: number;\n  hasChildren?: boolean;\n}\n\nexport interface AIRecommendation {\n  place: Place;\n  score: number;\n  reasoning: string;\n  category: StopCategory;\n  estimatedDuration: number;\n  weatherFit: number; // 0-1\n  detourTime: number; // minutes\n}\n\n// Voice Types\nexport interface VoiceIntent {\n  type: 'plan_create' | 'plan_update' | 'search' | 'navigate' | 'weather';\n  confidence: number;\n  parameters: Record<string, any>;\n  original: string;\n}\n\n// Provider Types\nexport interface RoutingProvider {\n  route(input: {\n    origin: LatLng;\n    destination: LatLng;\n    via?: LatLng[];\n    mode?: 'car' | 'bike' | 'walk';\n    avoidTolls?: boolean;\n    departTime?: Date;\n  }): Promise<Route>;\n}\n\nexport interface PlacesProvider {\n  search(\n    query: string,\n    options?: {\n      near?: LatLng;\n      type?: string;\n      openNow?: boolean;\n      radius?: number;\n    }\n  ): Promise<Place[]>;\n  details(placeId: string): Promise<PlaceDetail>;\n  photos(placeId: string, maxPhotos?: number): Promise<PhotoRef[]>;\n}\n\nexport interface WeatherProvider {\n  getCurrent(lat: number, lng: number): Promise<WeatherNow>;\n  getForecast(lat: number, lng: number, at?: Date): Promise<WeatherForecast>;\n}\n\n// Telemetry Types\nexport interface TelemetryEvent {\n  name: string;\n  properties?: Record<string, any>;\n  timestamp?: number;\n  sessionId?: string;\n  userId?: string;\n}\n\nexport interface PerformanceMetric {\n  name: string;\n  value: number;\n  unit?: string;\n  timestamp?: number;\n}\n\n// Error Types\nexport class AppError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public statusCode?: number,\n    public retryable = false\n  ) {\n    super(message);\n    this.name = 'AppError';\n  }\n}\n\n// Update Types\nexport interface AppVersion {\n  version: string;\n  buildDate: string;\n  features: string[];\n  fixes: string[];\n  breaking?: string[];\n}\n\nexport interface UpdateInfo {\n  available: boolean;\n  current: string;\n  latest: string;\n  releaseNotes?: AppVersion;\n  urgent?: boolean;\n}\n\n// Additional types for weather-aware routing\nexport interface WeatherData {\n  temperature: number;\n  conditions: string;\n  icon: string;\n  precipitation?: number;\n  windSpeed?: number;\n  humidity?: number;\n  pressure?: number;\n  visibility?: number;\n}\n\nexport interface RouteOptions {\n  mode?: 'car' | 'bike' | 'walk';\n  avoidTolls?: boolean;\n  avoidHighways?: boolean;\n  routePreference?: 'fastest' | 'shortest' | 'scenic';\n  departTime?: Date;\n  via?: LatLng[];\n}\n\n// Additional interfaces for the app"],"names":["apiKey","config","language","region","places","GooglePlacesProvider","routing","GoogleRoutesProvider","telemetry","exports","eventQueue","perfQueue","flushTimer","sessionId","constructor","this","enabled","undefined","endpoint","batchSize","flushInterval","generateSessionId","startPeriodicFlush","setupUnloadHandler","trackPageView","track","eventName","properties","event","name","userAgent","navigator","url","window","location","href","referrer","document","timestamp","Date","now","userId","push","checkFlushThreshold","trackPerformance","value","unit","metric","trackError","error","context","message","stack","trackUserAction","action","target","path","pathname","title","measureTime","fn","start","performance","result","Promise","finally","setUser","setProperty","key","globalThis","__telemetryGlobals","Math","random","toString","substr","setInterval","flush","addEventListener","handleUnload","visibilityState","length","synchronous","events","metrics","payload","map","sendBeacon","JSON","stringify","fetch","method","headers","Authorization","body","keepalive","console","warn","unshift","slice","destroy","clearInterval","PerformanceObserver","list","entries","getEntries","lastEntry","startTime","observe","entryTypes","forEach","entry","processingStart","clsValue","hadRecentInput","trackWebVitals","AppError","Error","code","statusCode","retryable","super","service","initializeService","google","loadGoogleMapsAPI","div","createElement","maps","PlacesService","resolve","reject","script","src","async","defer","onload","onerror","head","appendChild","search","query","options","request","near","LatLng","lat","lng","radius","type","openNow","textSearch","results","status","PlacesServiceStatus","OK","transformPlace","filter","Boolean","results_count","duration","has_location","details","placeId","fields","getDetails","place","placeDetail","transformPlaceDetail","place_id","photos","maxPhotos","gPlace","geometry","id","address","formatted_address","rating","userRatingsTotal","user_ratings_total","priceLevel","price_level","types","opening_hours","open_now","photo","getUrl","maxWidth","maxHeight","width","height","attributions","html_attributions","base","formattedAddress","phoneNumber","formatted_phone_number","website","openingHours","periods","period","open","day","time","close","weekdayText","weekday_text","reviews","review","author","author_name","text","vicinity","DirectionsService","route","input","origin","destination","waypoints","via","point","stopover","travelMode","getTravelMode","mode","avoidTolls","drivingOptions","departTime","departureTime","trafficModel","TrafficModel","BEST_GUESS","unitSystem","UnitSystem","METRIC","DirectionsStatus","transformRoute","has_waypoints","distance","overview","travel_time","TravelMode","WALKING","BICYCLING","TRANSIT","DRIVING","gRoute","routes","legs","leg","start_location","end","end_location","steps","step","instruction","instructions","polyline","points","maneuver","join","overview_polyline","bounds","north","getNorthEast","south","getSouthWest","east","west","reduce","sum","warnings","summary"],"mappings":"8EAsYO,SAA+BA,GACpC,MAAMC,EAAS,CAAED,SAAQE,SAAU,KAAMC,OAAQ,MAEjD,MAAO,CACLC,OAAQ,IAAIC,EAAqBJ,GACjCK,QAAS,IAAIC,EAAqBN,GAEtC,GCnIO,MAAMO,EAAAC,EAAA,IAAY,IA9PzB,MACUR,OACAS,WAA+B,GAC/BC,UAAiC,GACjCC,WACAC,UAERC,WAAAA,CAAYb,EAAmC,IAC7Cc,KAAKd,OAAS,CACZe,SAASC,EACTC,SAAqD,iBACrDC,UAAW,GACXC,cAAe,OACZnB,GAGLc,KAAKF,UAAYE,KAAKM,oBAElBN,KAAKd,OAAOe,UACdD,KAAKO,qBACLP,KAAKQ,qBACLR,KAAKS,gBAET,CAEAC,KAAAA,CAAMC,EAAmBC,GACvB,IAAKZ,KAAKd,OAAOe,QAAS,OAE1B,MAAMY,EAAwB,CAC5BC,KAAMH,EACNC,WAAY,IACPA,EACHG,UAAWC,UAAUD,UACrBE,IAAKC,OAAOC,SAASC,KACrBC,SAAUC,SAASD,UAErBE,UAAWC,KAAKC,MAChB3B,UAAWE,KAAKF,UAChB4B,OAAQ1B,KAAKd,OAAOwC,QAGtB1B,KAAKL,WAAWgC,KAAKd,GACrBb,KAAK4B,qBACP,CAEAC,gBAAAA,CAAiBf,EAAcgB,EAAeC,GAC5C,IAAK/B,KAAKd,OAAOe,QAAS,OAE1B,MAAM+B,EAA4B,CAChClB,OACAgB,QACAC,OACAR,UAAWC,KAAKC,OAGlBzB,KAAKJ,UAAU+B,KAAKK,GACpBhC,KAAK4B,qBACP,CAEAK,UAAAA,CAAWC,EAAcC,GAClBnC,KAAKd,OAAOe,SAEjBD,KAAKU,MAAM,QAAS,CAClB0B,QAASF,EAAME,QACfC,MAAOH,EAAMG,MACbvB,KAAMoB,EAAMpB,QACTqB,GAEP,CAEAG,eAAAA,CAAgBC,EAAgBC,EAAiB5B,GAC1CZ,KAAKd,OAAOe,SAEjBD,KAAKU,MAAM,cAAe,CACxB6B,SACAC,YACG5B,GAEP,CAEAH,aAAAA,CAAcgC,GACPzC,KAAKd,OAAOe,SAEjBD,KAAKU,MAAM,YAAa,CACtB+B,KAAMA,GAAQvB,OAAOC,SAASuB,SAC9BC,MAAOrB,SAASqB,OAEpB,CAEAC,WAAAA,CAAe9B,EAAc+B,GAC3B,IAAK7C,KAAKd,OAAOe,eAAgB4C,IAEjC,MAAMC,EAAQC,YAAYtB,MACpBuB,EAASH,IAEf,OAAIG,aAAkBC,QACbD,EAAOE,QAAQ,KACpBlD,KAAK6B,iBAAiBf,EAAMiC,YAAYtB,MAAQqB,EAAO,SAGzD9C,KAAK6B,iBAAiBf,EAAMiC,YAAYtB,MAAQqB,EAAO,MAChDE,EAEX,CAEAG,OAAAA,CAAQzB,GACN1B,KAAKd,OAAOwC,OAASA,CACvB,CAEA0B,WAAAA,CAAYC,EAAavB,GAEjBwB,WAAmBC,qBACtBD,WAAmBC,mBAAqB,CAAA,GAE1CD,WAAmBC,mBAAmBF,GAAOvB,CAChD,CAEQxB,iBAAAA,GACN,MAAO,GAAGkB,KAAKC,SAAS+B,KAAKC,SAASC,SAAS,IAAIC,OAAO,EAAG,IAC/D,CAEQpD,kBAAAA,GACNP,KAAKH,WAAaqB,OAAO0C,YAAY,KACnC5D,KAAK6D,SACJ7D,KAAKd,OAAOmB,cACjB,CAEQG,kBAAAA,GAKNU,OAAO4C,iBAAiB,eAJHC,KACnB/D,KAAK6D,OAAM,KAIb3C,OAAO4C,iBAAiB,mBAAoB,KACT,WAA7BxC,SAAS0C,iBACXhE,KAAK6D,SAGX,CAEQjC,mBAAAA,GACc5B,KAAKL,WAAWsE,OAASjE,KAAKJ,UAAUqE,QACzCjE,KAAKd,OAAOkB,WAC7BJ,KAAK6D,OAET,CAEA,WAAcA,CAAMK,GAAc,GAChC,GAA+B,IAA3BlE,KAAKL,WAAWsE,QAA0C,IAA1BjE,KAAKJ,UAAUqE,OACjD,OAGF,MAAME,EAAS,IAAInE,KAAKL,YAClByE,EAAU,IAAIpE,KAAKJ,WAGzBI,KAAKL,WAAa,GAClBK,KAAKJ,UAAY,GAEjB,MAAMyE,EAAU,CACdF,OAAQA,EAAOG,IAAIzD,IAAA,IACdA,EACHD,WAAY,IACPC,EAAMD,cACL0C,WAAmBC,uBAG3Ba,UACAtE,UAAWE,KAAKF,UAChByB,UAAWC,KAAKC,OAGlB,IACMyC,GAAe,eAAgBlD,UAEjCA,UAAUuD,WACRvE,KAAKd,OAAOiB,SACZqE,KAAKC,UAAUJ,UAGXK,MAAM1E,KAAKd,OAAOiB,SAAW,CACjCwE,OAAQ,OACRC,QAAS,CACP,eAAgB,sBACZ5E,KAAKd,OAAOD,QAAU,CAAE4F,cAAiB,UAAU7E,KAAKd,OAAOD,WAErE6F,KAAMN,KAAKC,UAAUJ,GACrBU,WAAW,GAGjB,OAAS7C,GACP8C,QAAQC,KAAK,4BAA6B/C,GAEtClC,KAAKL,WAAWsE,OAAS,MAC3BjE,KAAKL,WAAWuF,WAAWf,EAAOgB,OAAM,KACxCnF,KAAKJ,UAAUsF,WAAWd,EAAQe,OAAM,KAE5C,CACF,CAEAC,OAAAA,GACMpF,KAAKH,YACPwF,cAAcrF,KAAKH,YAErBG,KAAK6D,OAAM,EACb,IAoDoB,oBAAX3C,QAhDX,WACE,GAAM,wBAAyBA,OAE/B,IAEsB,IAAIoE,oBAAqBC,IAC3C,MAAMC,EAAUD,EAAKE,aACfC,EAAYF,EAAQA,EAAQvB,OAAS,GACvCyB,GACFjG,EAAUoC,iBAAiB,MAAO6D,EAAUC,UAAW,QAG/CC,QAAQ,CAAEC,WAAY,CAAC,8BAGf,IAAIP,oBAAqBC,IAC3BA,EAAKE,aACbK,QAASC,IACftG,EAAUoC,iBAAiB,MAAOkE,EAAMC,gBAAkBD,EAAMJ,UAAW,UAGnEC,QAAQ,CAAEC,WAAY,CAAC,iBAGnC,IAAII,EAAW,EACK,IAAIX,oBAAqBC,IAC3BA,EAAKE,aACbK,QAASC,IACVA,EAAMG,iBACTD,GAAYF,EAAMjE,WAIZ8D,QAAQ,CAAEC,WAAY,CAAC,kBAGnC3E,OAAO4C,iBAAiB,eAAgB,KACtCrE,EAAUoC,iBAAiB,MAAOoE,IAEtC,OAAS/D,GACP8C,QAAQC,KAAK,8BAA+B/C,EAC9C,CACF,CAOEiE,2HCHK,MAAMC,UAAiBC,MAC5BtG,WAAAA,CACEqC,EACOkE,EACAC,EACAC,GAAY,GAEnBC,MAAMrE,GAJCpC,KAAAsG,KAAAA,EACAtG,KAAAuG,WAAAA,EACAvG,KAAAwG,UAAAA,EAGPxG,KAAKc,KAAO,UACd,EACFpB,EAAA,IAAA0G,GFlQO,MAAM9G,EACHJ,OACAwH,QAER3G,WAAAA,CAAYb,GACVc,KAAKd,OAASA,EACdc,KAAK2G,mBACP,CAEA,uBAAcA,GACZ,GAAI3G,KAAK0G,QAAS,OAGI,oBAAXE,cACH5G,KAAK6G,oBAIb,MAAMC,EAAMxF,SAASyF,cAAc,OACnC/G,KAAK0G,QAAU,IAAIE,OAAOI,KAAK3H,OAAO4H,cAAcH,EACtD,CAEQD,iBAAAA,GACN,WAAW5D,QAAQ,CAACiE,EAASC,KAC3B,GAAsB,oBAAXP,OAET,YADAM,IAIF,MAAME,EAAS9F,SAASyF,cAAc,UACtCK,EAAOC,IAAM,+CAA+CrH,KAAKd,OAAOD,oCAAoCe,KAAKd,OAAOC,UAAY,OACpIiI,EAAOE,OAAQ,EACfF,EAAOG,OAAQ,EAEfH,EAAOI,OAAS,IAAMN,IACtBE,EAAOK,QAAU,IAAMN,EAAO,IAAIf,EAAS,iCAAkC,yBAE7E9E,SAASoG,KAAKC,YAAYP,IAE9B,CAEA,YAAMQ,CACJC,EACAC,EAKI,IAEJ,MAAMnC,EAAY5C,YAAYtB,MAE9B,eACakF,oBAEX,MAAMoB,EAAgD,CACpDF,QACA1G,SAAU2G,EAAQE,KAAO,IAAIpB,OAAOI,KAAKiB,OAAOH,EAAQE,KAAKE,IAAKJ,EAAQE,KAAKG,UAAO,EACtFC,OAAQN,EAAQM,QAAU,IAC1BC,KAAMP,EAAQO,KACdC,QAASR,EAAQQ,SAabjJ,SAVgB,IAAI4D,QAA0C,CAACiE,EAASC,KAC5EnH,KAAK0G,QAAS6B,WAAWR,EAAS,CAACS,EAASC,KACtCA,IAAW7B,OAAOI,KAAK3H,OAAOqJ,oBAAoBC,IAAMH,EAC1DtB,EAAQsB,GAERrB,EAAO,IAAIf,EAAS,yBAAyBqC,IAAU,8BAKtCnE,IAAItE,KAAK4I,gBAAgBC,OAAOC,SASvD,OAPArJ,EAAUiB,MAAM,gBAAiB,CAC/BmH,QACAkB,cAAe1J,EAAO4E,OACtB+E,SAAUjG,YAAYtB,MAAQkE,EAC9BsD,eAAgBnB,EAAQE,OAGnB3I,CACT,OAAS6C,GAMP,MALAzC,EAAUiB,MAAM,sBAAuB,CACrCmH,QACA3F,MAAOA,aAAiBmE,MAAQnE,EAAME,QAAU,gBAChD4G,SAAUjG,YAAYtB,MAAQkE,IAE1BzD,CACR,CACF,CAEA,aAAMgH,CAAQC,GACZ,MAAMxD,EAAY5C,YAAYtB,MAE9B,UACQzB,KAAK2G,oBAEX,MAAMoB,EAAkD,CACtDoB,UACAC,OAAQ,CACN,WAAY,OAAQ,oBAAqB,WACzC,SAAU,qBAAsB,cAAe,QAC/C,gBAAiB,yBAA0B,UAC3C,UAAW,SAAU,aAInBpG,QAAe,IAAIC,QAAwC,CAACiE,EAASC,KACzEnH,KAAK0G,QAAS2C,WAAWtB,EAAS,CAACuB,EAAOb,KACpCA,IAAW7B,OAAOI,KAAK3H,OAAOqJ,oBAAoBC,IAAMW,EAC1DpC,EAAQoC,GAERnC,EAAO,IAAIf,EAAS,yBAAyBqC,IAAU,6BAKvDc,EAAcvJ,KAAKwJ,qBAAqBxG,GAO9C,OALAvD,EAAUiB,MAAM,gBAAiB,CAC/B+I,SAAUN,EACVH,SAAUjG,YAAYtB,MAAQkE,IAGzB4D,CACT,OAASrH,GAMP,MALAzC,EAAUiB,MAAM,sBAAuB,CACrC+I,SAAUN,EACVjH,MAAOA,aAAiBmE,MAAQnE,EAAME,QAAU,gBAChD4G,SAAUjG,YAAYtB,MAAQkE,IAE1BzD,CACR,CACF,CAEA,YAAMwH,CAAOP,EAAiBQ,EAAY,GACxC,IACE,MAAMJ,QAAoBvJ,KAAKkJ,QAAQC,GACvC,OAAOI,EAAYG,QAAQvE,MAAM,EAAGwE,IAAc,EACpD,OAASzH,GAEP,OADA8C,QAAQC,KAAK,8BAA+B/C,GACrC,EACT,CACF,CAEQ0G,cAAAA,CAAegB,GACrB,OAAKA,EAAOH,UAAaG,EAAO9I,MAAS8I,EAAOC,UAAU1I,SAInD,CACL2I,GAAIF,EAAOH,SACX3I,KAAM8I,EAAO9I,KACbiJ,QAASH,EAAOI,kBAChB7I,SAAU,CACR+G,IAAK0B,EAAOC,SAAS1I,SAAS+G,MAC9BC,IAAKyB,EAAOC,SAAS1I,SAASgH,OAEhC8B,OAAQL,EAAOK,OACfC,iBAAkBN,EAAOO,mBACzBC,WAAYR,EAAOS,YACnBC,MAAOV,EAAOU,MACdhC,QAASsB,EAAOW,eAAeC,SAC/Bd,OAAQE,EAAOF,QAAQpF,IAAImG,IAAA,CACzBxJ,IAAKwJ,EAAMC,OAAO,CAAEC,SAAU,IAAKC,UAAW,MAC9CC,MAAO,IACPC,OAAQ,IACRC,aAAcN,EAAMO,0BAG1B,CAEQxB,oBAAAA,CAAqBI,GAC3B,MAAMqB,EAAOjL,KAAK4I,eAAegB,GACjC,IAAKqB,EACH,MAAM,IAAI7E,EAAS,qBAAsB,sBAG3C,MAAO,IACF6E,EACHC,iBAAkBtB,EAAOI,mBAAqBiB,EAAKlB,SAAW,GAC9DoB,YAAavB,EAAOwB,uBACpBC,QAASzB,EAAOyB,QAChBC,aAAc1B,EAAOW,cAAgB,CACnCjC,QAASsB,EAAOW,cAAcC,WAAY,EAC1Ce,QAAS3B,EAAOW,cAAcgB,SAASjH,IAAIkH,IAAA,CACzCC,KAAM,CACJC,IAAKF,EAAOC,MAAMC,KAAO,EACzBC,KAAMH,EAAOC,MAAME,MAAQ,QAE7BC,MAAOJ,EAAOI,MAAQ,CACpBF,IAAKF,EAAOI,MAAMF,IAClBC,KAAMH,EAAOI,MAAMD,WACjB,MACC,GACPE,YAAajC,EAAOW,cAAcuB,cAAgB,SAChD,EACJC,QAASnC,EAAOmC,SAASzH,IAAI0H,IAAA,CAC3BC,OAAQD,EAAOE,YACfjC,OAAQ+B,EAAO/B,OACfkC,KAAMH,EAAOG,KACbR,KAAMK,EAAOL,QAEfS,SAAUxC,EAAOwC,SAErB,EAIK,MAAM5M,EACHN,OACAwH,QAER3G,WAAAA,CAAYb,GACVc,KAAKd,OAASA,EACdc,KAAK2G,mBACP,CAEA,uBAAcA,GACR3G,KAAK0G,UAEa,oBAAXE,cACH5G,KAAK6G,oBAGb7G,KAAK0G,QAAU,IAAIE,OAAOI,KAAKqF,kBACjC,CAEQxF,iBAAAA,GACN,OAAO,IAAI5D,QAAQ,CAACiE,EAASC,KAC3B,GAAsB,oBAAXP,OAET,YADAM,IAIF,MAAME,EAAS9F,SAASyF,cAAc,UACtCK,EAAOC,IAAM,+CAA+CrH,KAAKd,OAAOD,mBAAmBe,KAAKd,OAAOC,UAAY,OACnHiI,EAAOE,OAAQ,EACfF,EAAOG,OAAQ,EAEfH,EAAOI,OAAS,IAAMN,IACtBE,EAAOK,QAAU,IAAMN,EAAO,IAAIf,EAAS,iCAAkC,yBAE7E9E,SAASoG,KAAKC,YAAYP,IAE9B,CAEA,WAAMkF,CAAMC,GAQV,MAAM5G,EAAY5C,YAAYtB,MAE9B,UACQzB,KAAK2G,oBAEX,MAAMoB,EAAyC,CAC7CyE,OAAQ,IAAI5F,OAAOI,KAAKiB,OAAOsE,EAAMC,OAAOtE,IAAKqE,EAAMC,OAAOrE,KAC9DsE,YAAa,IAAI7F,OAAOI,KAAKiB,OAAOsE,EAAME,YAAYvE,IAAKqE,EAAME,YAAYtE,KAC7EuE,UAAWH,EAAMI,KAAKrI,IAAIsI,KACxBzL,SAAU,IAAIyF,OAAOI,KAAKiB,OAAO2E,EAAM1E,IAAK0E,EAAMzE,KAClD0E,UAAU,KAEZC,WAAY9M,KAAK+M,cAAcR,EAAMS,MAAQ,OAC7CC,WAAYV,EAAMU,aAAc,EAChCC,eAAgBX,EAAMY,WAAa,CACjCC,cAAeb,EAAMY,WACrBE,aAAczG,OAAOI,KAAKsG,aAAaC,iBACrC,EACJC,WAAY5G,OAAOI,KAAKyG,WAAWC,QAG/B1K,QAAe,IAAIC,QAAsC,CAACiE,EAASC,KACvEnH,KAAK0G,QAAS4F,MAAMvE,EAAS,CAAC/E,EAAQyF,KAChCA,IAAW7B,OAAOI,KAAK2G,iBAAiBhF,IAAM3F,EAChDkE,EAAQlE,GAERmE,EAAO,IAAIf,EAAS,6BAA6BqC,IAAU,iCAK3D6D,EAAQtM,KAAK4N,eAAe5K,GAUlC,OARAvD,EAAUiB,MAAM,oBAAqB,CACnCsM,KAAMT,EAAMS,KACZa,gBAAkBtB,EAAMI,KAAK1I,OAC7B+E,SAAUjG,YAAYtB,MAAQkE,EAC9BmI,SAAUxB,EAAMyB,SAASD,SACzBE,YAAa1B,EAAMyB,SAAS/E,WAGvBsD,CACT,OAASpK,GAMP,MALAzC,EAAUiB,MAAM,0BAA2B,CACzCsM,KAAMT,EAAMS,KACZ9K,MAAOA,aAAiBmE,MAAQnE,EAAME,QAAU,gBAChD4G,SAAUjG,YAAYtB,MAAQkE,IAE1BzD,CACR,CACF,CAEQ6K,aAAAA,CAAcC,GACpB,OAAQA,GACN,IAAK,OAAQ,OAAOpG,OAAOI,KAAKiH,WAAWC,QAC3C,IAAK,OAAQ,OAAOtH,OAAOI,KAAKiH,WAAWE,UAC3C,IAAK,UAAW,OAAOvH,OAAOI,KAAKiH,WAAWG,QAC9C,QAAS,OAAOxH,OAAOI,KAAKiH,WAAWI,QAE3C,CAEQT,cAAAA,CAAeU,GACrB,MAAMhC,EAAQgC,EAAOC,OAAO,GAC5B,IAAKjC,EACH,MAAM,IAAIlG,EAAS,iBAAkB,kBAGvC,MAAO,CACLoI,KAAMlC,EAAMkC,KAAKlK,IAAImK,IAAA,CACnB3L,MAAO,CACLoF,IAAKuG,EAAIC,eAAexG,MACxBC,IAAKsG,EAAIC,eAAevG,OAE1BwG,IAAK,CACHzG,IAAKuG,EAAIG,aAAa1G,MACtBC,IAAKsG,EAAIG,aAAazG,OAExBa,SAAUyF,EAAIzF,UAAUlH,OAAS,EACjCgM,SAAUW,EAAIX,UAAUhM,OAAS,EACjC+M,MAAOJ,EAAII,MAAMvK,IAAIwK,KACnBC,YAAaD,EAAKE,aAClBhG,SAAU8F,EAAK9F,UAAUlH,OAAS,EAClCgM,SAAUgB,EAAKhB,UAAUhM,OAAS,EAClCgB,MAAO,CACLoF,IAAK4G,EAAKJ,eAAexG,MACzBC,IAAK2G,EAAKJ,eAAevG,OAE3BwG,IAAK,CACHzG,IAAK4G,EAAKF,aAAa1G,MACvBC,IAAK2G,EAAKF,aAAazG,OAEzB8G,SAAUH,EAAKG,UAAUC,QAAU,GACnCC,SAAUL,EAAKK,YAEjBF,SAAUR,EAAII,MAAMvK,IAAIwK,GAAQA,EAAKG,UAAUC,QAAQE,KAAK,OAE9DrB,SAAU,CACRkB,SAAU3C,EAAM+C,mBAAmBH,QAAU,GAC7CI,OAAQ,CACNC,MAAOjD,EAAMgD,QAAQE,eAAetH,OAAS,EAC7CuH,MAAOnD,EAAMgD,QAAQI,eAAexH,OAAS,EAC7CyH,KAAMrD,EAAMgD,QAAQE,eAAerH,OAAS,EAC5CyH,KAAMtD,EAAMgD,QAAQI,eAAevH,OAAS,GAE9Ca,SAAUsD,EAAMkC,KAAKqB,OAAO,CAACC,EAAKrB,IAAQqB,GAAOrB,EAAIzF,UAAUlH,OAAS,GAAI,GAC5EgM,SAAUxB,EAAMkC,KAAKqB,OAAO,CAACC,EAAKrB,IAAQqB,GAAOrB,EAAIX,UAAUhM,OAAS,GAAI,IAE9EiO,SAAUzD,EAAMyD,SAChBC,QAAS1D,EAAM0D,QAEnB"}