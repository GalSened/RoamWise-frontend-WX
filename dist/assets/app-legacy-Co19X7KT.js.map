{"version":3,"file":"app-legacy-Co19X7KT.js","sources":["../../src/core/app.ts","../../src/core/theme/tokens.ts","../../src/lib/utils/events.ts","../../src/core/theme/ThemeProvider.ts","../../src/core/update/UpdateManager.ts","../../src/providers/routing/osrm.ts","../../src/features/routing/WeatherAwareRouter.ts","../../src/core/ai/AIOrchestrator.ts","../../src/lib/storage/index.ts","../../src/features/planning/PlanningManager.ts","../../src/features/voice/VoiceManager.ts","../../src/features/navigation/NavigationManager.ts","../../src/features/map/MapManager.ts","../../src/features/ui/UIManager.ts"],"sourcesContent":["import { themeProvider } from './theme/ThemeProvider';\nimport { updateManager } from './update/UpdateManager';\nimport { createGoogleProviders } from '../providers/google/maps';\nimport { createOpenWeatherProvider } from '../providers/weather/openweather';\nimport { createOSRMProvider } from '../providers/routing/osrm';\nimport { createWeatherAwareRouter } from '../features/routing/WeatherAwareRouter';\nimport { createAIOrchestrator } from './ai/AIOrchestrator';\nimport { planningManager } from '../features/planning/PlanningManager';\nimport { voiceManager } from '../features/voice/VoiceManager';\nimport { navigationManager } from '../features/navigation/NavigationManager';\nimport { MapManager } from '../features/map/MapManager';\nimport { UIManager } from '../features/ui/UIManager';\nimport { telemetry } from '../lib/telemetry';\n\ninterface AppConfig {\n  googleMapsApiKey?: string;\n  openWeatherApiKey?: string;\n  routingProvider: 'google' | 'osrm';\n  weatherProvider: 'openweather';\n}\n\nclass TravelingApp {\n  private config: AppConfig;\n  private providers: any = {};\n  private managers: any = {};\n  private aiOrchestrator: any;\n  private isInitialized = false;\n\n  constructor() {\n    this.config = {\n      googleMapsApiKey: import.meta.env.VITE_GOOGLE_MAPS_API_KEY,\n      openWeatherApiKey: import.meta.env.VITE_OPENWEATHER_API_KEY,\n      routingProvider: (import.meta.env.VITE_ROUTING_PROVIDER as 'google' | 'osrm') || 'google',\n      weatherProvider: 'openweather'\n    };\n  }\n\n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    telemetry.track('app_initialization_started');\n    \n    try {\n      // Initialize core systems\n      await this.initializeTheme();\n      await this.initializeProviders();\n      await this.initializeManagers();\n      await this.initializeUI();\n      await this.setupEventHandlers();\n      \n      this.isInitialized = true;\n      telemetry.track('app_initialization_completed');\n      \n      // Check for updates after initialization\n      setTimeout(() => updateManager.checkForUpdates(), 2000);\n      \n    } catch (error) {\n      telemetry.track('app_initialization_failed', {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      throw error;\n    }\n  }\n\n  private async initializeTheme(): Promise<void> {\n    // Theme provider auto-initializes, just ensure it's ready\n    const theme = themeProvider.getEffectiveTheme();\n    telemetry.track('theme_initialized', { theme });\n  }\n\n  private async initializeProviders(): Promise<void> {\n    // Google Maps providers\n    if (this.config.googleMapsApiKey) {\n      const googleProviders = createGoogleProviders(this.config.googleMapsApiKey);\n      this.providers.googlePlaces = googleProviders.places;\n      this.providers.googleRouting = googleProviders.routing;\n    }\n\n    // Routing provider\n    if (this.config.routingProvider === 'google' && this.providers.googleRouting) {\n      this.providers.routing = this.providers.googleRouting;\n    } else {\n      this.providers.routing = createOSRMProvider();\n    }\n\n    // Weather provider\n    if (this.config.openWeatherApiKey) {\n      this.providers.weather = createOpenWeatherProvider(this.config.openWeatherApiKey);\n    }\n\n    // Weather-aware routing\n    if (this.providers.routing && this.providers.weather) {\n      this.providers.weatherAwareRouter = createWeatherAwareRouter(\n        this.providers.routing,\n        this.providers.weather\n      );\n    }\n\n    // Places provider fallback\n    this.providers.places = this.providers.googlePlaces || {\n      search: async () => [],\n      details: async () => ({}),\n      photos: async () => []\n    };\n\n    telemetry.track('providers_initialized', {\n      routing: this.config.routingProvider,\n      weather: this.config.weatherProvider,\n      places: this.providers.googlePlaces ? 'google' : 'fallback'\n    });\n  }\n\n  private async initializeManagers(): Promise<void> {\n    // AI Orchestrator\n    if (this.providers.places && this.providers.routing && this.providers.weather) {\n      this.aiOrchestrator = createAIOrchestrator(\n        this.providers.places,\n        this.providers.routing,\n        this.providers.weather\n      );\n    }\n\n    // Map Manager\n    this.managers.map = new MapManager({\n      providers: this.providers\n    });\n\n    // UI Manager\n    this.managers.ui = new UIManager({\n      planningManager,\n      voiceManager,\n      navigationManager,\n      aiOrchestrator: this.aiOrchestrator,\n      providers: this.providers\n    });\n\n    telemetry.track('managers_initialized');\n  }\n\n  private async initializeUI(): Promise<void> {\n    await this.managers.ui.initialize();\n    await this.managers.map.initialize();\n    \n    telemetry.track('ui_initialized');\n  }\n\n  private async setupEventHandlers(): Promise<void> {\n    // Theme change handler\n    themeProvider.on('theme-changed', (data) => {\n      this.managers.map?.updateTheme(data.theme);\n      telemetry.track('theme_changed', { theme: data.theme });\n    });\n\n    // Update notifications\n    updateManager.on('update-available', (updateInfo) => {\n      this.managers.ui?.showUpdateNotification(updateInfo);\n      telemetry.track('update_notification_shown', updateInfo);\n    });\n\n    // Voice intent handling\n    voiceManager.on('intent-recognized', async (intent) => {\n      if (this.aiOrchestrator) {\n        try {\n          const result = await this.aiOrchestrator.processVoiceIntent(intent, {\n            location: this.managers.map?.getCurrentLocation(),\n            userPreferences: await this.getUserPreferences()\n          });\n          \n          this.managers.ui?.handleAIResult(intent.type, result);\n        } catch (error) {\n          console.error('Voice intent processing failed:', error);\n          this.managers.ui?.showError('Failed to process voice command');\n        }\n      }\n    });\n\n    // Navigation events\n    navigationManager.on('navigation-started', () => {\n      this.managers.ui?.enterNavigationMode();\n    });\n\n    navigationManager.on('navigation-stopped', () => {\n      this.managers.ui?.exitNavigationMode();\n    });\n\n    // Global error handling\n    window.addEventListener('error', (event) => {\n      this.managers.ui?.showError('An unexpected error occurred');\n    });\n\n    telemetry.track('event_handlers_setup');\n  }\n\n  private async getUserPreferences(): Promise<Record<string, any>> {\n    // Load user preferences from storage\n    return {\n      language: navigator.language,\n      units: 'metric',\n      categories: ['meal', 'scenic', 'activity']\n    };\n  }\n\n  // Public API\n  getProviders() {\n    return this.providers;\n  }\n\n  getManagers() {\n    return this.managers;\n  }\n\n  getAIOrchestrator() {\n    return this.aiOrchestrator;\n  }\n\n  isReady(): boolean {\n    return this.isInitialized;\n  }\n}\n\n// Global app instance\nconst app = new TravelingApp();\n\n// Export initialization function\nexport async function initializeApp(): Promise<void> {\n  await app.initialize();\n}\n\n// Export app instance for debugging\nif (import.meta.env.DEV) {\n  (window as any).__travelingApp = app;\n}\n\nexport { app };","import type { ThemeColors } from '@/types';\n\nexport const lightTheme: ThemeColors = {\n  primary: '#0066cc',\n  secondary: '#6366f1',\n  background: '#ffffff',\n  surface: '#f8fafc',\n  text: '#1e293b',\n  textSecondary: '#64748b',\n  border: '#e2e8f0',\n  success: '#10b981',\n  warning: '#f59e0b',\n  error: '#ef4444'\n};\n\nexport const darkTheme: ThemeColors = {\n  primary: '#3b82f6',\n  secondary: '#8b5cf6',\n  background: '#0f172a',\n  surface: '#1e293b',\n  text: '#f1f5f9',\n  textSecondary: '#94a3b8',\n  border: '#334155',\n  success: '#34d399',\n  warning: '#fbbf24',\n  error: '#f87171'\n};\n\nexport const spacing = {\n  xs: '0.25rem',   // 4px\n  sm: '0.5rem',    // 8px\n  md: '1rem',      // 16px\n  lg: '1.5rem',    // 24px\n  xl: '2rem',      // 32px\n  '2xl': '3rem',   // 48px\n  '3xl': '4rem'    // 64px\n};\n\nexport const typography = {\n  fontFamily: {\n    sans: ['Rubik', 'system-ui', 'sans-serif'],\n    mono: ['SF Mono', 'Monaco', 'Cascadia Code', 'monospace']\n  },\n  fontSize: {\n    xs: '0.75rem',\n    sm: '0.875rem',\n    base: '1rem',\n    lg: '1.125rem',\n    xl: '1.25rem',\n    '2xl': '1.5rem',\n    '3xl': '1.875rem',\n    '4xl': '2.25rem'\n  },\n  fontWeight: {\n    normal: '400',\n    medium: '500',\n    semibold: '600',\n    bold: '700'\n  }\n};\n\nexport const borderRadius = {\n  none: '0',\n  sm: '0.125rem',\n  md: '0.375rem',\n  lg: '0.5rem',\n  xl: '0.75rem',\n  '2xl': '1rem',\n  full: '9999px'\n};\n\nexport const shadows = {\n  sm: '0 1px 2px 0 rgb(0 0 0 / 0.05)',\n  md: '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)',\n  lg: '0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)',\n  xl: '0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)'\n};\n\nexport const zIndex = {\n  dropdown: 1000,\n  sticky: 1020,\n  fixed: 1030,\n  modal: 1040,\n  popover: 1050,\n  tooltip: 1060,\n  toast: 1070\n};\n\nexport const breakpoints = {\n  sm: '640px',\n  md: '768px',\n  lg: '1024px',\n  xl: '1280px',\n  '2xl': '1536px'\n};\n\nexport const animations = {\n  duration: {\n    fast: '150ms',\n    normal: '300ms',\n    slow: '500ms'\n  },\n  easing: {\n    linear: 'linear',\n    ease: 'ease',\n    easeIn: 'ease-in',\n    easeOut: 'ease-out',\n    easeInOut: 'ease-in-out'\n  }\n};","// Event system utilities\n\nexport function createCustomEvent<T = any>(name: string, detail?: T): CustomEvent<T> {\n  return new CustomEvent(name, { detail });\n}\n\nexport class EventBus {\n  private listeners = new Map<string, Set<Function>>();\n\n  on(event: string, callback: Function): void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    this.listeners.get(event)!.add(callback);\n  }\n\n  off(event: string, callback: Function): void {\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      eventListeners.delete(callback);\n      if (eventListeners.size === 0) {\n        this.listeners.delete(event);\n      }\n    }\n  }\n\n  emit(event: string, data?: any): void {\n    const eventListeners = this.listeners.get(event);\n    if (eventListeners) {\n      eventListeners.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`Error in event listener for ${event}:`, error);\n        }\n      });\n    }\n  }\n\n  once(event: string, callback: Function): void {\n    const wrapper = (...args: any[]) => {\n      this.off(event, wrapper);\n      callback(...args);\n    };\n    this.on(event, wrapper);\n  }\n\n  destroy(): void {\n    this.listeners.clear();\n  }\n}\n\n// Global event bus for cross-component communication\nexport const globalEvents = new EventBus();","import type { Theme, ThemeColors } from '@/types';\nimport { lightTheme, darkTheme } from './tokens';\nimport { createCustomEvent, EventBus } from '@/lib/utils/events';\n\nclass ThemeProvider extends EventBus {\n  private currentTheme: Theme = 'system';\n  private prefersDark = false;\n  private mediaQuery: MediaQueryList;\n\n  constructor() {\n    super();\n    this.mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');\n    this.prefersDark = this.mediaQuery.matches;\n    \n    // Listen for system theme changes\n    this.mediaQuery.addEventListener('change', (e) => {\n      this.prefersDark = e.matches;\n      if (this.currentTheme === 'system') {\n        this.applyTheme();\n        this.emit('theme-changed', { theme: this.getEffectiveTheme() });\n      }\n    });\n\n    // Load saved theme or use system default\n    this.loadTheme();\n    this.applyTheme();\n  }\n\n  private loadTheme(): void {\n    const saved = localStorage.getItem('app-theme') as Theme;\n    if (saved && ['light', 'dark', 'system'].includes(saved)) {\n      this.currentTheme = saved;\n    }\n  }\n\n  private saveTheme(): void {\n    localStorage.setItem('app-theme', this.currentTheme);\n  }\n\n  getTheme(): Theme {\n    return this.currentTheme;\n  }\n\n  getEffectiveTheme(): 'light' | 'dark' {\n    if (this.currentTheme === 'system') {\n      return this.prefersDark ? 'dark' : 'light';\n    }\n    return this.currentTheme;\n  }\n\n  getColors(): ThemeColors {\n    return this.getEffectiveTheme() === 'dark' ? darkTheme : lightTheme;\n  }\n\n  setTheme(theme: Theme): void {\n    if (this.currentTheme === theme) return;\n    \n    this.currentTheme = theme;\n    this.saveTheme();\n    this.applyTheme();\n    this.emit('theme-changed', { theme: this.getEffectiveTheme() });\n  }\n\n  toggleTheme(): void {\n    const current = this.getEffectiveTheme();\n    this.setTheme(current === 'light' ? 'dark' : 'light');\n  }\n\n  private applyTheme(): void {\n    const effective = this.getEffectiveTheme();\n    const colors = this.getColors();\n    \n    // Update CSS custom properties\n    const root = document.documentElement;\n    Object.entries(colors).forEach(([key, value]) => {\n      root.style.setProperty(`--color-${key}`, value);\n    });\n\n    // Update data attribute for CSS targeting\n    root.setAttribute('data-theme', effective);\n    \n    // Update meta theme-color for mobile browsers\n    const themeColorMeta = document.querySelector('meta[name=\"theme-color\"]') as HTMLMetaElement;\n    if (themeColorMeta) {\n      themeColorMeta.content = colors.primary;\n    }\n\n    // Update map style if Leaflet map exists\n    this.updateMapStyle(effective);\n  }\n\n  private updateMapStyle(theme: 'light' | 'dark'): void {\n    // Dispatch event for map to update its basemap\n    window.dispatchEvent(createCustomEvent('map-theme-change', { theme }));\n  }\n\n  // CSS-in-JS helper for components\n  getCSSVariables(): Record<string, string> {\n    const colors = this.getColors();\n    const vars: Record<string, string> = {};\n    \n    Object.entries(colors).forEach(([key, value]) => {\n      vars[`--color-${key}`] = value;\n    });\n    \n    return vars;\n  }\n\n  // Helper for conditional styling\n  isDark(): boolean {\n    return this.getEffectiveTheme() === 'dark';\n  }\n\n  // Get theme-appropriate map tiles URL\n  getMapTileURL(): string {\n    const isDark = this.isDark();\n    \n    if (isDark) {\n      // Use dark tiles from CartoDB or similar\n      return 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';\n    } else {\n      // Use light tiles\n      return 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';\n    }\n  }\n\n  getMapTileAttribution(): string {\n    const isDark = this.isDark();\n    \n    if (isDark) {\n      return '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors &copy; <a href=\"https://carto.com/attributions\">CARTO</a>';\n    } else {\n      return '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors';\n    }\n  }\n}\n\n// Global singleton instance\nexport const themeProvider = new ThemeProvider();\n\n// React-like hook interface for easy integration\nexport function useTheme() {\n  return {\n    theme: themeProvider.getTheme(),\n    effectiveTheme: themeProvider.getEffectiveTheme(),\n    colors: themeProvider.getColors(),\n    setTheme: themeProvider.setTheme.bind(themeProvider),\n    toggleTheme: themeProvider.toggleTheme.bind(themeProvider),\n    isDark: themeProvider.isDark(),\n    subscribe: (callback: (theme: string) => void) => {\n      themeProvider.on('theme-changed', callback);\n      return () => themeProvider.off('theme-changed', callback);\n    }\n  };\n}","import type { AppVersion, UpdateInfo } from '@/types';\nimport { EventBus } from '@/lib/utils/events';\nimport { telemetry } from '@/lib/telemetry';\n\ninterface UpdateConfig {\n  checkInterval: number; // milliseconds\n  apiEndpoint: string;\n  currentVersion: string;\n  autoCheck: boolean;\n}\n\nclass UpdateManager extends EventBus {\n  private config: UpdateConfig;\n  private checkTimer?: number;\n  private lastCheckTime = 0;\n  private updateAvailable = false;\n  private latestVersion?: AppVersion;\n\n  constructor(config: Partial<UpdateConfig> = {}) {\n    super();\n    \n    this.config = {\n      checkInterval: 30 * 60 * 1000, // 30 minutes\n      apiEndpoint: '/app/version.json',\n      currentVersion: '2.0.0', // This should come from build process\n      autoCheck: true,\n      ...config\n    };\n\n    if (this.config.autoCheck) {\n      this.startPeriodicCheck();\n    }\n  }\n\n  async checkForUpdates(force = false): Promise<UpdateInfo> {\n    const now = Date.now();\n    \n    // Avoid too frequent checks unless forced\n    if (!force && now - this.lastCheckTime < 5 * 60 * 1000) {\n      return this.getLastUpdateInfo();\n    }\n\n    this.lastCheckTime = now;\n    telemetry.track('update_check_started');\n\n    try {\n      const response = await fetch(this.config.apiEndpoint, {\n        cache: 'no-cache',\n        headers: {\n          'Cache-Control': 'no-cache',\n          'Pragma': 'no-cache'\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`Update check failed: ${response.status}`);\n      }\n\n      const latestVersion: AppVersion = await response.json();\n      const updateInfo = this.compareVersions(latestVersion);\n      \n      this.latestVersion = latestVersion;\n      this.updateAvailable = updateInfo.available;\n      \n      if (updateInfo.available) {\n        this.emit('update-available', updateInfo);\n        telemetry.track('update_available', {\n          current: updateInfo.current,\n          latest: updateInfo.latest,\n          urgent: updateInfo.urgent\n        });\n      }\n\n      telemetry.track('update_check_completed', {\n        available: updateInfo.available,\n        version: updateInfo.latest\n      });\n\n      return updateInfo;\n    } catch (error) {\n      console.error('Update check failed:', error);\n      telemetry.track('update_check_failed', {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      \n      return {\n        available: false,\n        current: this.config.currentVersion,\n        latest: this.config.currentVersion\n      };\n    }\n  }\n\n  private compareVersions(latest: AppVersion): UpdateInfo {\n    const current = this.config.currentVersion;\n    const available = this.isNewerVersion(latest.version, current);\n    \n    return {\n      available,\n      current,\n      latest: latest.version,\n      releaseNotes: available ? latest : undefined,\n      urgent: available && latest.breaking && latest.breaking.length > 0\n    };\n  }\n\n  private isNewerVersion(latest: string, current: string): boolean {\n    const latestParts = latest.split('.').map(Number);\n    const currentParts = current.split('.').map(Number);\n    \n    for (let i = 0; i < Math.max(latestParts.length, currentParts.length); i++) {\n      const latestPart = latestParts[i] || 0;\n      const currentPart = currentParts[i] || 0;\n      \n      if (latestPart > currentPart) return true;\n      if (latestPart < currentPart) return false;\n    }\n    \n    return false;\n  }\n\n  getLastUpdateInfo(): UpdateInfo {\n    return {\n      available: this.updateAvailable,\n      current: this.config.currentVersion,\n      latest: this.latestVersion?.version || this.config.currentVersion,\n      releaseNotes: this.updateAvailable ? this.latestVersion : undefined,\n      urgent: this.updateAvailable && this.latestVersion?.breaking && this.latestVersion.breaking.length > 0\n    };\n  }\n\n  async applyUpdate(): Promise<void> {\n    if (!this.updateAvailable) {\n      throw new Error('No update available');\n    }\n\n    telemetry.track('update_apply_started');\n\n    try {\n      // For PWA, trigger service worker update\n      if ('serviceWorker' in navigator) {\n        const registration = await navigator.serviceWorker.getRegistration();\n        if (registration && registration.waiting) {\n          // There's a waiting service worker, activate it\n          registration.waiting.postMessage({ type: 'SKIP_WAITING' });\n          this.emit('update-applied');\n          telemetry.track('update_applied', { method: 'service_worker' });\n          return;\n        }\n      }\n\n      // For other platforms, redirect to store or reload\n      if (this.isNativeApp()) {\n        this.redirectToStore();\n      } else {\n        // Force reload to get new version\n        window.location.reload();\n      }\n    } catch (error) {\n      console.error('Update application failed:', error);\n      telemetry.track('update_apply_failed', {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      throw error;\n    }\n  }\n\n  private isNativeApp(): boolean {\n    // Detect if running in native app context\n    return !!(\n      (window as any).ReactNativeWebView ||\n      (window as any).webkit?.messageHandlers ||\n      navigator.userAgent.includes('TravelingApp')\n    );\n  }\n\n  private redirectToStore(): void {\n    const userAgent = navigator.userAgent;\n    \n    if (userAgent.includes('iPhone') || userAgent.includes('iPad')) {\n      // iOS App Store\n      window.open('https://apps.apple.com/app/traveling-app', '_blank');\n    } else if (userAgent.includes('Android')) {\n      // Google Play Store\n      window.open('https://play.google.com/store/apps/details?id=com.traveling.app', '_blank');\n    } else {\n      // Web - just reload\n      window.location.reload();\n    }\n  }\n\n  private startPeriodicCheck(): void {\n    this.checkTimer = window.setInterval(() => {\n      this.checkForUpdates();\n    }, this.config.checkInterval);\n  }\n\n  stopPeriodicCheck(): void {\n    if (this.checkTimer) {\n      clearInterval(this.checkTimer);\n      this.checkTimer = undefined;\n    }\n  }\n\n  destroy(): void {\n    this.stopPeriodicCheck();\n    super.destroy();\n  }\n}\n\n// Service worker message handler for update notifications\nif ('serviceWorker' in navigator) {\n  navigator.serviceWorker.addEventListener('message', (event) => {\n    if (event.data?.type === 'UPDATE_AVAILABLE') {\n      updateManager.emit('update-available', {\n        available: true,\n        current: updateManager.getLastUpdateInfo().current,\n        latest: event.data.version || 'unknown'\n      });\n    }\n  });\n}\n\n// Global singleton\nexport const updateManager = new UpdateManager({\n  currentVersion: import.meta.env.VITE_APP_VERSION || '2.0.0'\n});\n\n// Convenience hook\nexport function useUpdate() {\n  return {\n    checkForUpdates: updateManager.checkForUpdates.bind(updateManager),\n    applyUpdate: updateManager.applyUpdate.bind(updateManager),\n    getUpdateInfo: updateManager.getLastUpdateInfo.bind(updateManager),\n    subscribe: (callback: (updateInfo: UpdateInfo) => void) => {\n      updateManager.on('update-available', callback);\n      return () => updateManager.off('update-available', callback);\n    }\n  };\n}","import type { RoutingProvider, Route, LatLng } from '@/types';\nimport { AppError } from '@/types';\nimport { telemetry } from '@/lib/telemetry';\n\ninterface OSRMConfig {\n  baseUrl?: string;\n  profile?: 'driving' | 'walking' | 'cycling';\n}\n\ninterface OSRMResponse {\n  routes: Array<{\n    legs: Array<{\n      steps: Array<{\n        intersections: Array<{\n          location: [number, number];\n        }>;\n        maneuver: {\n          instruction: string;\n          type: string;\n          location: [number, number];\n        };\n        name: string;\n        duration: number;\n        distance: number;\n        geometry: {\n          coordinates: Array<[number, number]>;\n        };\n      }>;\n      summary: string;\n      duration: number;\n      distance: number;\n    }>;\n    geometry: {\n      coordinates: Array<[number, number]>;\n    };\n    duration: number;\n    distance: number;\n  }>;\n}\n\nexport class OSRMProvider implements RoutingProvider {\n  private config: OSRMConfig;\n\n  constructor(config: OSRMConfig = {}) {\n    this.config = {\n      baseUrl: 'https://router.project-osrm.org',\n      profile: 'driving',\n      ...config\n    };\n  }\n\n  async route(input: {\n    origin: LatLng;\n    destination: LatLng;\n    via?: LatLng[];\n    mode?: 'car' | 'bike' | 'walk';\n    avoidTolls?: boolean;\n    departTime?: Date;\n  }): Promise<Route> {\n    const startTime = performance.now();\n    \n    try {\n      const profile = this.getOSRMProfile(input.mode || 'car');\n      const coordinates = [\n        input.origin,\n        ...(input.via || []),\n        input.destination\n      ];\n\n      const coordString = coordinates\n        .map(coord => `${coord.lng},${coord.lat}`)\n        .join(';');\n\n      const url = new URL(`${this.config.baseUrl}/route/v1/${profile}/${coordString}`);\n      url.searchParams.set('overview', 'full');\n      url.searchParams.set('geometries', 'geojson');\n      url.searchParams.set('steps', 'true');\n      url.searchParams.set('annotations', 'true');\n\n      const response = await fetch(url.toString());\n      \n      if (!response.ok) {\n        throw new AppError(\n          `OSRM API error: ${response.status}`,\n          'OSRM_API_ERROR',\n          response.status\n        );\n      }\n\n      const data: OSRMResponse = await response.json();\n      \n      if (!data.routes || data.routes.length === 0) {\n        throw new AppError('No route found', 'NO_ROUTE_FOUND');\n      }\n\n      const route = this.transformRoute(data.routes[0]);\n      \n      telemetry.track('osrm_route_calculation', {\n        mode: input.mode,\n        has_waypoints: !!(input.via?.length),\n        duration: performance.now() - startTime,\n        distance: route.overview.distance,\n        travel_time: route.overview.duration\n      });\n\n      return route;\n    } catch (error) {\n      telemetry.track('osrm_route_calculation_error', {\n        mode: input.mode,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        duration: performance.now() - startTime\n      });\n      throw error;\n    }\n  }\n\n  private getOSRMProfile(mode: string): string {\n    switch (mode) {\n      case 'walk': return 'foot';\n      case 'bike': return 'cycling';\n      default: return 'driving';\n    }\n  }\n\n  private transformRoute(osrmRoute: OSRMResponse['routes'][0]): Route {\n    return {\n      legs: osrmRoute.legs.map(leg => ({\n        start: {\n          lng: leg.steps[0]?.intersections[0]?.location[0] || 0,\n          lat: leg.steps[0]?.intersections[0]?.location[1] || 0\n        },\n        end: {\n          lng: leg.steps[leg.steps.length - 1]?.intersections[0]?.location[0] || 0,\n          lat: leg.steps[leg.steps.length - 1]?.intersections[0]?.location[1] || 0\n        },\n        duration: leg.duration,\n        distance: leg.distance,\n        steps: leg.steps.map(step => ({\n          instruction: step.maneuver.instruction,\n          duration: step.duration,\n          distance: step.distance,\n          start: {\n            lng: step.maneuver.location[0],\n            lat: step.maneuver.location[1]\n          },\n          end: {\n            lng: step.geometry.coordinates[step.geometry.coordinates.length - 1][0],\n            lat: step.geometry.coordinates[step.geometry.coordinates.length - 1][1]\n          },\n          polyline: this.encodePolyline(step.geometry.coordinates),\n          maneuver: step.maneuver.type\n        })),\n        polyline: this.encodePolyline(\n          leg.steps.flatMap(step => step.geometry.coordinates)\n        )\n      })),\n      overview: {\n        polyline: this.encodePolyline(osrmRoute.geometry.coordinates),\n        bounds: this.calculateBounds(osrmRoute.geometry.coordinates),\n        duration: osrmRoute.duration,\n        distance: osrmRoute.distance\n      },\n      warnings: [],\n      summary: 'OSRM Route'\n    };\n  }\n\n  private calculateBounds(coordinates: Array<[number, number]>) {\n    const lngs = coordinates.map(coord => coord[0]);\n    const lats = coordinates.map(coord => coord[1]);\n    \n    return {\n      north: Math.max(...lats),\n      south: Math.min(...lats),\n      east: Math.max(...lngs),\n      west: Math.min(...lngs)\n    };\n  }\n\n  private encodePolyline(coordinates: Array<[number, number]>): string {\n    // Simple polyline encoding - in production, use a proper library\n    return coordinates\n      .map(coord => `${coord[1]},${coord[0]}`)\n      .join(' ');\n  }\n}\n\n// Factory function\nexport function createOSRMProvider(baseUrl?: string): RoutingProvider {\n  return new OSRMProvider({ baseUrl });\n}","import type { \n  Route, \n  LatLng, \n  RoutingProvider, \n  WeatherProvider, \n  RouteOptions,\n  WeatherData \n} from '@/types';\nimport { EventBus } from '@/lib/utils/events';\nimport { telemetry } from '@/lib/telemetry';\n\ninterface WeatherRouteScore {\n  originalRoute: Route;\n  weatherScore: number;\n  weatherFactors: {\n    precipitation: number; // 0-1 (1 = no rain, 0 = heavy rain)\n    temperature: number;   // 0-1 (1 = comfortable, 0 = extreme)\n    visibility: number;    // 0-1 (1 = clear, 0 = poor visibility)\n    wind: number;         // 0-1 (1 = calm, 0 = dangerous winds)\n    overall: number;      // combined weather fitness score\n  };\n  recommendation: 'proceed' | 'delay' | 'indoor_route' | 'cancel';\n  weatherAlerts: string[];\n  alternativeRoutes?: WeatherRouteScore[];\n}\n\ninterface WeatherRouteOptions extends RouteOptions {\n  weatherAware?: boolean;\n  weatherThreshold?: number; // Minimum weather score to proceed (0-1)\n  includeAlternatives?: boolean;\n  maxAlternatives?: number;\n}\n\nexport class WeatherAwareRouter extends EventBus {\n  private routingProvider: RoutingProvider;\n  private weatherProvider: WeatherProvider;\n  private routeCache = new Map<string, { route: Route; timestamp: number }>();\n  private weatherCache = new Map<string, { data: WeatherData; timestamp: number }>();\n  private cacheTimeout = 5 * 60 * 1000; // 5 minutes\n\n  constructor(routingProvider: RoutingProvider, weatherProvider: WeatherProvider) {\n    super();\n    this.routingProvider = routingProvider;\n    this.weatherProvider = weatherProvider;\n  }\n\n  async calculateWeatherAwareRoute(\n    origin: LatLng,\n    destination: LatLng,\n    options: WeatherRouteOptions = {}\n  ): Promise<WeatherRouteScore> {\n    const startTime = performance.now();\n    \n    try {\n      // Step 1: Get basic route\n      const basicRoute = await this.getBasicRoute(origin, destination, options);\n\n      // Step 2: If weather awareness is disabled, return basic route\n      if (!options.weatherAware) {\n        return {\n          originalRoute: basicRoute,\n          weatherScore: 0.7, // neutral score\n          weatherFactors: this.getNeutralWeatherFactors(),\n          recommendation: 'proceed',\n          weatherAlerts: []\n        };\n      }\n\n      // Step 3: Analyze weather along route\n      const weatherAnalysis = await this.analyzeRouteWeather(basicRoute);\n\n      // Step 4: Score route based on weather\n      const weatherScore = this.calculateWeatherScore(weatherAnalysis);\n\n      // Step 5: Generate recommendations\n      const recommendation = this.generateWeatherRecommendation(weatherScore, options);\n\n      // Step 6: Get alternative routes if needed\n      let alternativeRoutes: WeatherRouteScore[] = [];\n      if (options.includeAlternatives && (weatherScore.overall < 0.6 || options.maxAlternatives)) {\n        alternativeRoutes = await this.generateAlternativeRoutes(\n          origin, \n          destination, \n          basicRoute, \n          options\n        );\n      }\n\n      const result: WeatherRouteScore = {\n        originalRoute: basicRoute,\n        weatherScore: weatherScore.overall,\n        weatherFactors: weatherScore,\n        recommendation,\n        weatherAlerts: this.generateWeatherAlerts(weatherAnalysis, weatherScore),\n        alternativeRoutes\n      };\n\n      telemetry.track('weather_aware_route_calculated', {\n        weather_score: weatherScore.overall,\n        recommendation,\n        has_alternatives: alternativeRoutes.length > 0,\n        duration: performance.now() - startTime\n      });\n\n      this.emit('route-calculated', result);\n      return result;\n\n    } catch (error) {\n      telemetry.track('weather_aware_route_error', {\n        error: error instanceof Error ? error.message : 'Unknown error',\n        duration: performance.now() - startTime\n      });\n      throw error;\n    }\n  }\n\n  private async getBasicRoute(\n    origin: LatLng, \n    destination: LatLng, \n    options: RouteOptions\n  ): Promise<Route> {\n    const cacheKey = `${origin.lat},${origin.lng}-${destination.lat},${destination.lng}-${JSON.stringify(options)}`;\n    const cached = this.routeCache.get(cacheKey);\n    \n    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {\n      return cached.route;\n    }\n\n    const route = await this.routingProvider.route({ origin, destination, ...options });\n    this.routeCache.set(cacheKey, { route, timestamp: Date.now() });\n    \n    return route;\n  }\n\n  private async analyzeRouteWeather(route: Route): Promise<WeatherData[]> {\n    const weatherPoints = this.extractWeatherCheckpoints(route);\n    const weatherPromises = weatherPoints.map(point => this.getWeatherForPoint(point));\n    \n    return Promise.all(weatherPromises);\n  }\n\n  private extractWeatherCheckpoints(route: Route): LatLng[] {\n    const checkpoints: LatLng[] = [];\n    \n    // Add start and end points\n    if (route.legs.length > 0) {\n      checkpoints.push(route.legs[0].start);\n      checkpoints.push(route.legs[route.legs.length - 1].end);\n    }\n\n    // Add intermediate points (every ~20km or major waypoints)\n    route.legs.forEach(leg => {\n      if (leg.distance > 20000) { // 20km+\n        // Add a midpoint for long legs\n        const midpoint = this.interpolateLatLng(leg.start, leg.end, 0.5);\n        checkpoints.push(midpoint);\n      }\n    });\n\n    return checkpoints;\n  }\n\n  private async getWeatherForPoint(point: LatLng): Promise<WeatherData> {\n    const cacheKey = `${point.lat.toFixed(3)},${point.lng.toFixed(3)}`;\n    const cached = this.weatherCache.get(cacheKey);\n    \n    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {\n      return cached.data;\n    }\n\n    const weather = await this.weatherProvider.getCurrent(point.lat, point.lng);\n    this.weatherCache.set(cacheKey, { data: weather, timestamp: Date.now() });\n    \n    return weather;\n  }\n\n  private calculateWeatherScore(weatherData: WeatherData[]): WeatherRouteScore['weatherFactors'] {\n    if (weatherData.length === 0) {\n      return this.getNeutralWeatherFactors();\n    }\n\n    // Aggregate weather conditions across all points\n    const avgWeather = this.aggregateWeatherData(weatherData);\n    \n    // Score each weather factor (0-1, higher is better)\n    const precipitation = this.scorePrecipitation(avgWeather.precipitation);\n    const temperature = this.scoreTemperature(avgWeather.temperature);\n    const visibility = this.scoreVisibility(avgWeather.visibility);\n    const wind = this.scoreWind(avgWeather.windSpeed);\n\n    // Calculate overall score with weights\n    const overall = (\n      precipitation * 0.4 +  // Rain is most important for driving\n      temperature * 0.2 +    // Temperature affects comfort\n      visibility * 0.3 +     // Visibility is crucial for safety\n      wind * 0.1            // Wind is least critical for most routes\n    );\n\n    return {\n      precipitation,\n      temperature,\n      visibility,\n      wind,\n      overall\n    };\n  }\n\n  private aggregateWeatherData(weatherData: WeatherData[]): any {\n    const count = weatherData.length;\n    \n    return {\n      temperature: weatherData.reduce((sum, w) => sum + w.temperature, 0) / count,\n      precipitation: Math.max(...weatherData.map(w => w.precipitation || 0)),\n      windSpeed: weatherData.reduce((sum, w) => sum + (w.windSpeed || 0), 0) / count,\n      visibility: Math.min(...weatherData.map(w => w.visibility || 10)) // km\n    };\n  }\n\n  private scorePrecipitation(precipitation: number): number {\n    // precipitation in mm/h\n    if (precipitation <= 0.5) return 1.0;      // No rain\n    if (precipitation <= 2.5) return 0.8;     // Light rain\n    if (precipitation <= 7.5) return 0.5;     // Moderate rain\n    if (precipitation <= 15) return 0.2;      // Heavy rain\n    return 0.0; // Very heavy rain\n  }\n\n  private scoreTemperature(temperature: number): number {\n    // temperature in Celsius - score based on driving comfort\n    if (temperature >= 15 && temperature <= 25) return 1.0; // Ideal\n    if (temperature >= 10 && temperature <= 30) return 0.8; // Good\n    if (temperature >= 5 && temperature <= 35) return 0.6;  // Acceptable\n    if (temperature >= 0 && temperature <= 40) return 0.3;  // Uncomfortable\n    return 0.1; // Extreme temperatures\n  }\n\n  private scoreVisibility(visibility: number): number {\n    // visibility in km\n    if (visibility >= 10) return 1.0;   // Excellent\n    if (visibility >= 5) return 0.8;    // Good\n    if (visibility >= 2) return 0.5;    // Fair\n    if (visibility >= 1) return 0.2;    // Poor\n    return 0.0; // Very poor\n  }\n\n  private scoreWind(windSpeed: number): number {\n    // wind speed in km/h\n    if (windSpeed <= 20) return 1.0;    // Calm to light breeze\n    if (windSpeed <= 40) return 0.8;    // Moderate wind\n    if (windSpeed <= 60) return 0.5;    // Strong wind\n    if (windSpeed <= 80) return 0.2;    // Very strong wind\n    return 0.0; // Dangerous winds\n  }\n\n  private generateWeatherRecommendation(\n    weatherScore: WeatherRouteScore['weatherFactors'],\n    options: WeatherRouteOptions\n  ): WeatherRouteScore['recommendation'] {\n    const threshold = options.weatherThreshold || 0.6;\n    \n    if (weatherScore.overall >= threshold) {\n      return 'proceed';\n    }\n    \n    // Analyze specific issues\n    if (weatherScore.precipitation < 0.3) {\n      return 'delay'; // Heavy rain\n    }\n    \n    if (weatherScore.visibility < 0.3) {\n      return 'delay'; // Poor visibility\n    }\n    \n    if (weatherScore.wind < 0.2) {\n      return 'cancel'; // Dangerous winds\n    }\n    \n    if (weatherScore.overall < 0.3) {\n      return 'cancel'; // Multiple severe issues\n    }\n    \n    return 'indoor_route'; // Try alternatives with more indoor stops\n  }\n\n  private generateWeatherAlerts(\n    weatherData: WeatherData[],\n    weatherScore: WeatherRouteScore['weatherFactors']\n  ): string[] {\n    const alerts: string[] = [];\n    \n    if (weatherScore.precipitation < 0.5) {\n      alerts.push('⚠️ Heavy rain expected along route. Consider delaying travel.');\n    }\n    \n    if (weatherScore.visibility < 0.5) {\n      alerts.push('🌫️ Reduced visibility due to fog or weather conditions.');\n    }\n    \n    if (weatherScore.wind < 0.5) {\n      alerts.push('💨 Strong winds reported. Drive carefully, especially in open areas.');\n    }\n    \n    if (weatherScore.temperature < 0.3) {\n      const avgTemp = weatherData.reduce((sum, w) => sum + w.temperature, 0) / weatherData.length;\n      if (avgTemp < 0) {\n        alerts.push('🧊 Freezing conditions. Watch for ice on roads.');\n      } else if (avgTemp > 35) {\n        alerts.push('🌡️ Extremely hot weather. Ensure vehicle cooling and hydration.');\n      }\n    }\n    \n    return alerts;\n  }\n\n  private async generateAlternativeRoutes(\n    origin: LatLng,\n    destination: LatLng,\n    originalRoute: Route,\n    options: WeatherRouteOptions\n  ): Promise<WeatherRouteScore[]> {\n    const alternatives: WeatherRouteScore[] = [];\n    const maxAlternatives = options.maxAlternatives || 2;\n    \n    // Try different routing preferences\n    const alternativeOptions = [\n      { ...options, routePreference: 'shortest' as const },\n      { ...options, avoidHighways: true },\n      { ...options, avoidTolls: true }\n    ];\n\n    for (const altOptions of alternativeOptions.slice(0, maxAlternatives)) {\n      try {\n        const altRoute = await this.getBasicRoute(origin, destination, altOptions);\n        \n        // Skip if route is too similar to original\n        if (this.routesSimilar(originalRoute, altRoute)) continue;\n        \n        const weatherAnalysis = await this.analyzeRouteWeather(altRoute);\n        const weatherScore = this.calculateWeatherScore(weatherAnalysis);\n        const recommendation = this.generateWeatherRecommendation(weatherScore, options);\n        \n        alternatives.push({\n          originalRoute: altRoute,\n          weatherScore: weatherScore.overall,\n          weatherFactors: weatherScore,\n          recommendation,\n          weatherAlerts: this.generateWeatherAlerts(weatherAnalysis, weatherScore)\n        });\n      } catch (error) {\n        console.warn('Failed to generate alternative route:', error);\n      }\n    }\n    \n    // Sort by weather score (best weather first)\n    return alternatives.sort((a, b) => b.weatherScore - a.weatherScore);\n  }\n\n  private routesSimilar(route1: Route, route2: Route): boolean {\n    // Simple similarity check based on distance and duration\n    const distanceDiff = Math.abs(route1.overview.distance - route2.overview.distance);\n    const durationDiff = Math.abs(route1.overview.duration - route2.overview.duration);\n    \n    return distanceDiff < route1.overview.distance * 0.1 && \n           durationDiff < route1.overview.duration * 0.1;\n  }\n\n  private getNeutralWeatherFactors(): WeatherRouteScore['weatherFactors'] {\n    return {\n      precipitation: 0.7,\n      temperature: 0.7,\n      visibility: 0.7,\n      wind: 0.7,\n      overall: 0.7\n    };\n  }\n\n  private interpolateLatLng(start: LatLng, end: LatLng, ratio: number): LatLng {\n    return {\n      lat: start.lat + (end.lat - start.lat) * ratio,\n      lng: start.lng + (end.lng - start.lng) * ratio\n    };\n  }\n\n  // Public API for real-time weather updates during navigation\n  async updateRouteWeather(route: Route): Promise<WeatherRouteScore['weatherFactors']> {\n    const weatherData = await this.analyzeRouteWeather(route);\n    const weatherScore = this.calculateWeatherScore(weatherData);\n    \n    this.emit('route-weather-updated', weatherScore);\n    return weatherScore;\n  }\n\n  // Get weather forecast for route planning\n  async getRouteForecast(\n    origin: LatLng,\n    destination: LatLng,\n    departureTime: Date\n  ): Promise<{ hourlyWeather: any[]; recommendation: string }> {\n    try {\n      const forecastData = await this.weatherProvider.getForecast(origin.lat, origin.lng);\n      \n      // Find forecast closest to departure time\n      const departureHour = departureTime.getHours();\n      const relevantForecast = forecastData.hourly?.slice(departureHour, departureHour + 6) || [];\n      \n      const weatherScore = this.calculateWeatherScore(relevantForecast);\n      let recommendation = 'Good weather for travel';\n      \n      if (weatherScore.overall < 0.4) {\n        recommendation = 'Consider delaying travel due to poor weather conditions';\n      } else if (weatherScore.overall < 0.6) {\n        recommendation = 'Acceptable weather, drive carefully';\n      }\n      \n      return {\n        hourlyWeather: relevantForecast,\n        recommendation\n      };\n    } catch (error) {\n      console.warn('Failed to get route forecast:', error);\n      return {\n        hourlyWeather: [],\n        recommendation: 'Weather data unavailable'\n      };\n    }\n  }\n\n  clearCache(): void {\n    this.routeCache.clear();\n    this.weatherCache.clear();\n  }\n}\n\n// Factory function\nexport function createWeatherAwareRouter(\n  routingProvider: RoutingProvider,\n  weatherProvider: WeatherProvider\n): WeatherAwareRouter {\n  return new WeatherAwareRouter(routingProvider, weatherProvider);\n}","import type { \n  PlacesProvider, \n  RoutingProvider, \n  WeatherProvider, \n  AIRecommendation,\n  PlanningConstraints,\n  TripPlan,\n  VoiceIntent,\n  LatLng,\n  Place\n} from '@/types';\nimport { AppError } from '@/types';\nimport { EventBus } from '@/lib/utils/events';\nimport { telemetry } from '@/lib/telemetry';\n\ninterface AITool {\n  name: string;\n  description: string;\n  execute(parameters: any): Promise<any>;\n}\n\ninterface PlannerResult {\n  plan: Partial<TripPlan>;\n  reasoning: string;\n  confidence: number;\n  alternatives?: Partial<TripPlan>[];\n}\n\nclass PlannerAgent {\n  constructor(\n    private placesProvider: PlacesProvider,\n    private routingProvider: RoutingProvider,\n    private weatherProvider: WeatherProvider\n  ) {}\n\n  async createPlan(input: {\n    destination?: string;\n    origin?: LatLng;\n    constraints: PlanningConstraints;\n    userPreferences?: Record<string, any>;\n  }): Promise<PlannerResult> {\n    const startTime = performance.now();\n    \n    try {\n      // Step 1: Understand the destination\n      let destinationPlaces: Place[] = [];\n      if (input.destination) {\n        destinationPlaces = await this.placesProvider.search(input.destination, {\n          near: input.origin\n        });\n      }\n\n      // Step 2: Get weather context if weather-aware\n      let weatherContext;\n      if (input.constraints.weatherAware && input.origin) {\n        weatherContext = await this.weatherProvider.getForecast(\n          input.origin.lat,\n          input.origin.lng\n        );\n      }\n\n      // Step 3: Find candidate stops based on constraints\n      const candidates = await this.findCandidateStops(input, weatherContext);\n\n      // Step 4: Score and rank candidates\n      const recommendations = await this.scoreRecommendations(candidates, input, weatherContext);\n\n      // Step 5: Create optimized itinerary\n      const plan = await this.createOptimizedItinerary(recommendations, input);\n\n      telemetry.track('ai_plan_created', {\n        destination: input.destination,\n        candidates_count: candidates.length,\n        recommendations_count: recommendations.length,\n        duration: performance.now() - startTime,\n        weather_aware: input.constraints.weatherAware\n      });\n\n      return {\n        plan,\n        reasoning: this.generatePlanReasoning(plan, recommendations, weatherContext),\n        confidence: this.calculatePlanConfidence(plan, recommendations),\n        alternatives: [] // TODO: Generate alternatives\n      };\n    } catch (error) {\n      telemetry.track('ai_plan_creation_error', {\n        error: error instanceof Error ? error.message : 'Unknown error',\n        duration: performance.now() - startTime\n      });\n      throw error;\n    }\n  }\n\n  private async findCandidateStops(\n    input: any,\n    weatherContext?: any\n  ): Promise<Place[]> {\n    const candidates: Place[] = [];\n    const searchRadius = 10000; // 10km\n\n    if (!input.origin) return candidates;\n\n    // Search for different categories\n    const categories = input.constraints.categories || ['meal', 'scenic', 'activity'];\n    \n    for (const category of categories) {\n      try {\n        const categoryPlaces = await this.placesProvider.search(\n          this.getCategorySearchTerm(category),\n          {\n            near: input.origin,\n            radius: searchRadius,\n            openNow: true\n          }\n        );\n        candidates.push(...categoryPlaces);\n      } catch (error) {\n        console.warn(`Failed to search for ${category}:`, error);\n      }\n    }\n\n    return candidates;\n  }\n\n  private getCategorySearchTerm(category: string): string {\n    const terms = {\n      meal: 'restaurants cafes food',\n      scenic: 'viewpoint scenic attractions parks',\n      activity: 'attractions activities things to do',\n      cultural: 'museums galleries cultural sites',\n      shopping: 'shopping centers markets stores'\n    };\n    return terms[category as keyof typeof terms] || category;\n  }\n\n  private async scoreRecommendations(\n    places: Place[],\n    input: any,\n    weatherContext?: any\n  ): Promise<AIRecommendation[]> {\n    return places.map(place => {\n      const scores = {\n        rating: this.scoreRating(place.rating),\n        distance: this.scoreDistance(place, input.origin),\n        weather: this.scoreWeatherFit(place, weatherContext),\n        openNow: place.openNow ? 1 : 0.3,\n        priceLevel: this.scorePriceLevel(place.priceLevel, input.constraints.budget)\n      };\n\n      const weightedScore = \n        scores.rating * 0.3 +\n        scores.distance * 0.2 +\n        scores.weather * 0.2 +\n        scores.openNow * 0.2 +\n        scores.priceLevel * 0.1;\n\n      return {\n        place,\n        score: weightedScore,\n        reasoning: this.generateRecommendationReasoning(scores, place),\n        category: this.inferCategory(place),\n        estimatedDuration: this.estimateDuration(place),\n        weatherFit: scores.weather,\n        detourTime: 0 // TODO: Calculate actual detour time\n      };\n    }).sort((a, b) => b.score - a.score);\n  }\n\n  private scoreRating(rating?: number): number {\n    if (!rating) return 0.5;\n    return Math.min(rating / 5, 1);\n  }\n\n  private scoreDistance(place: Place, origin?: LatLng): number {\n    if (!origin) return 0.5;\n    \n    const distance = this.calculateDistance(\n      origin,\n      place.location\n    );\n    \n    // Prefer places within 5km, penalize beyond 20km\n    if (distance <= 5000) return 1;\n    if (distance <= 10000) return 0.8;\n    if (distance <= 20000) return 0.5;\n    return 0.2;\n  }\n\n  private scoreWeatherFit(place: Place, weatherContext?: any): number {\n    if (!weatherContext || !place.types) return 0.7;\n\n    const isIndoor = place.types.some(type => \n      ['museum', 'shopping_mall', 'restaurant', 'cafe'].includes(type)\n    );\n    \n    const isOutdoor = place.types.some(type =>\n      ['park', 'tourist_attraction', 'natural_feature'].includes(type)\n    );\n\n    const currentWeather = weatherContext.hourly?.[0];\n    if (!currentWeather) return 0.7;\n\n    // If it's raining, prefer indoor activities\n    if (currentWeather.precipitation > 5) {\n      return isIndoor ? 1 : 0.3;\n    }\n\n    // If it's very hot, prefer indoor or shaded activities\n    if (currentWeather.temperature > 30) {\n      return isIndoor ? 0.9 : 0.6;\n    }\n\n    // Good weather, prefer outdoor activities\n    if (currentWeather.temperature > 15 && currentWeather.precipitation < 1) {\n      return isOutdoor ? 1 : 0.7;\n    }\n\n    return 0.7;\n  }\n\n  private scorePriceLevel(priceLevel?: number, budget?: { min: number; max: number }): number {\n    if (!priceLevel || !budget) return 0.7;\n\n    // Google Places price levels: 0 (free) to 4 (very expensive)\n    const estimatedCost = priceLevel * 50; // Rough estimate\n    \n    if (estimatedCost >= budget.min && estimatedCost <= budget.max) return 1;\n    if (estimatedCost < budget.min) return 0.8; // Cheaper is usually okay\n    if (estimatedCost > budget.max * 1.5) return 0.2; // Way over budget\n    return 0.5; // Slightly over budget\n  }\n\n  private generateRecommendationReasoning(scores: any, place: Place): string {\n    const reasons = [];\n    \n    if (scores.rating > 0.8) reasons.push('highly rated');\n    if (scores.distance > 0.8) reasons.push('nearby');\n    if (scores.weather > 0.8) reasons.push('perfect for current weather');\n    if (scores.openNow === 1) reasons.push('open now');\n    \n    return reasons.length > 0 \n      ? `Great choice: ${reasons.join(', ')}`\n      : 'Good option for your trip';\n  }\n\n  private inferCategory(place: Place): any {\n    if (!place.types) return 'other';\n    \n    if (place.types.includes('restaurant') || place.types.includes('cafe')) return 'meal';\n    if (place.types.includes('tourist_attraction')) return 'scenic';\n    if (place.types.includes('museum')) return 'cultural';\n    if (place.types.includes('shopping_mall')) return 'shopping';\n    \n    return 'activity';\n  }\n\n  private estimateDuration(place: Place): number {\n    const category = this.inferCategory(place);\n    const durations = {\n      meal: 90,\n      scenic: 60,\n      cultural: 120,\n      shopping: 180,\n      activity: 120,\n      other: 60\n    };\n    return durations[category as keyof typeof durations] || 60;\n  }\n\n  private async createOptimizedItinerary(\n    recommendations: AIRecommendation[],\n    input: any\n  ): Promise<Partial<TripPlan>> {\n    const maxStops = Math.min(recommendations.length, 8); // Reasonable limit\n    const selectedStops = recommendations.slice(0, maxStops);\n\n    return {\n      name: input.destination ? `Trip to ${input.destination}` : 'Custom Trip',\n      description: 'AI-generated trip plan based on your preferences',\n      stops: selectedStops.map((rec, index) => ({\n        id: `stop-${index}`,\n        place: rec.place,\n        category: rec.category,\n        priority: Math.max(1, Math.ceil(rec.score * 5)),\n        duration: rec.estimatedDuration,\n        weatherDependent: rec.weatherFit < 0.5,\n        notes: rec.reasoning\n      }))\n    };\n  }\n\n  private generatePlanReasoning(plan: any, recommendations: AIRecommendation[], weatherContext?: any): string {\n    const reasons = [\n      `Selected ${plan.stops?.length || 0} stops based on ratings, proximity, and your preferences.`\n    ];\n\n    if (weatherContext) {\n      const currentWeather = weatherContext.hourly?.[0];\n      if (currentWeather?.precipitation > 5) {\n        reasons.push('Prioritized indoor activities due to rain forecast.');\n      } else if (currentWeather?.temperature > 25) {\n        reasons.push('Balanced indoor and outdoor activities for comfort in warm weather.');\n      }\n    }\n\n    const highRatedCount = recommendations.filter(r => r.score > 0.8).length;\n    if (highRatedCount > 0) {\n      reasons.push(`Included ${highRatedCount} highly-rated recommendations.`);\n    }\n\n    return reasons.join(' ');\n  }\n\n  private calculatePlanConfidence(plan: any, recommendations: AIRecommendation[]): number {\n    if (!recommendations.length) return 0;\n    \n    const avgScore = recommendations.reduce((sum, rec) => sum + rec.score, 0) / recommendations.length;\n    const hasHighQuality = recommendations.some(rec => rec.score > 0.8);\n    \n    return Math.min(avgScore + (hasHighQuality ? 0.2 : 0), 1);\n  }\n\n  private calculateDistance(from: LatLng, to: LatLng): number {\n    const R = 6371e3; // Earth's radius in meters\n    const φ1 = from.lat * Math.PI / 180;\n    const φ2 = to.lat * Math.PI / 180;\n    const Δφ = (to.lat - from.lat) * Math.PI / 180;\n    const Δλ = (to.lng - from.lng) * Math.PI / 180;\n\n    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +\n              Math.cos(φ1) * Math.cos(φ2) *\n              Math.sin(Δλ/2) * Math.sin(Δλ/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n\n    return R * c;\n  }\n}\n\nclass AIOrchestrator extends EventBus {\n  private plannerAgent: PlannerAgent;\n  private tools = new Map<string, AITool>();\n\n  constructor(\n    private placesProvider: PlacesProvider,\n    private routingProvider: RoutingProvider,\n    private weatherProvider: WeatherProvider\n  ) {\n    super();\n    this.plannerAgent = new PlannerAgent(placesProvider, routingProvider, weatherProvider);\n    this.initializeTools();\n  }\n\n  private initializeTools(): void {\n    // Search Tool\n    this.registerTool({\n      name: 'search_places',\n      description: 'Search for places near a location',\n      execute: async (params: { query: string; location?: LatLng }) => {\n        return this.placesProvider.search(params.query, {\n          near: params.location\n        });\n      }\n    });\n\n    // Route Tool\n    this.registerTool({\n      name: 'calculate_route',\n      description: 'Calculate route between locations',\n      execute: async (params: { origin: LatLng; destination: LatLng }) => {\n        return this.routingProvider.route(params);\n      }\n    });\n\n    // Weather Tool\n    this.registerTool({\n      name: 'get_weather',\n      description: 'Get weather information for a location',\n      execute: async (params: { location: LatLng; forecast?: boolean }) => {\n        if (params.forecast) {\n          return this.weatherProvider.getForecast(params.location.lat, params.location.lng);\n        } else {\n          return this.weatherProvider.getCurrent(params.location.lat, params.location.lng);\n        }\n      }\n    });\n  }\n\n  registerTool(tool: AITool): void {\n    this.tools.set(tool.name, tool);\n  }\n\n  async processVoiceIntent(intent: VoiceIntent, context?: any): Promise<any> {\n    telemetry.track('ai_voice_intent_processed', {\n      intent_type: intent.type,\n      confidence: intent.confidence\n    });\n\n    switch (intent.type) {\n      case 'plan_create':\n        return this.handlePlanCreate(intent, context);\n      case 'plan_update':\n        return this.handlePlanUpdate(intent, context);\n      case 'search':\n        return this.handleSearch(intent, context);\n      case 'navigate':\n        return this.handleNavigate(intent, context);\n      case 'weather':\n        return this.handleWeather(intent, context);\n      default:\n        throw new AppError(`Unsupported intent type: ${intent.type}`, 'UNSUPPORTED_INTENT');\n    }\n  }\n\n  private async handlePlanCreate(intent: VoiceIntent, context?: any): Promise<PlannerResult> {\n    const destination = intent.parameters.destination;\n    const constraints: PlanningConstraints = {\n      weatherAware: true,\n      maxDrivingTime: 8 * 60, // 8 hours\n      ...context?.constraints\n    };\n\n    return this.plannerAgent.createPlan({\n      destination,\n      origin: context?.location,\n      constraints,\n      userPreferences: context?.userPreferences\n    });\n  }\n\n  private async handlePlanUpdate(intent: VoiceIntent, context?: any): Promise<any> {\n    // TODO: Implement plan update logic\n    return { action: 'plan_update', parameters: intent.parameters };\n  }\n\n  private async handleSearch(intent: VoiceIntent, context?: any): Promise<Place[]> {\n    const query = intent.parameters.query;\n    const location = context?.location;\n\n    const tool = this.tools.get('search_places');\n    if (!tool) throw new AppError('Search tool not available', 'TOOL_NOT_FOUND');\n\n    return tool.execute({ query, location });\n  }\n\n  private async handleNavigate(intent: VoiceIntent, context?: any): Promise<any> {\n    // TODO: Implement navigation logic\n    return { action: 'navigate', parameters: intent.parameters };\n  }\n\n  private async handleWeather(intent: VoiceIntent, context?: any): Promise<any> {\n    const location = context?.location;\n    if (!location) {\n      throw new AppError('Location required for weather information', 'LOCATION_REQUIRED');\n    }\n\n    const tool = this.tools.get('get_weather');\n    if (!tool) throw new AppError('Weather tool not available', 'TOOL_NOT_FOUND');\n\n    return tool.execute({ location, forecast: true });\n  }\n\n  async explainRecommendation(recommendation: AIRecommendation): Promise<string> {\n    const reasons = [\n      `This place has a score of ${(recommendation.score * 100).toFixed(0)}% based on multiple factors:`\n    ];\n\n    if (recommendation.place.rating && recommendation.place.rating > 4) {\n      reasons.push(`• Highly rated (${recommendation.place.rating}⭐) by ${recommendation.place.userRatingsTotal || 'many'} visitors`);\n    }\n\n    if (recommendation.weatherFit > 0.8) {\n      reasons.push('• Perfect for current weather conditions');\n    } else if (recommendation.weatherFit < 0.4) {\n      reasons.push('• Consider weather conditions when visiting');\n    }\n\n    if (recommendation.detourTime < 10) {\n      reasons.push('• Very close to your route (minimal detour)');\n    }\n\n    reasons.push(`• Estimated visit duration: ${recommendation.estimatedDuration} minutes`);\n    reasons.push(`• Category: ${recommendation.category}`);\n\n    return reasons.join('\\n');\n  }\n}\n\n// Factory function to create AI orchestrator\nexport function createAIOrchestrator(\n  placesProvider: PlacesProvider,\n  routingProvider: RoutingProvider,\n  weatherProvider: WeatherProvider\n): AIOrchestrator {\n  return new AIOrchestrator(placesProvider, routingProvider, weatherProvider);\n}","// Storage abstraction layer supporting localStorage, IndexedDB, and memory fallback\n\ninterface StorageAdapter {\n  get(key: string): Promise<any>;\n  set(key: string, value: any): Promise<void>;\n  remove(key: string): Promise<void>;\n  clear(): Promise<void>;\n  keys(): Promise<string[]>;\n}\n\nclass LocalStorageAdapter implements StorageAdapter {\n  async get(key: string): Promise<any> {\n    try {\n      const item = localStorage.getItem(key);\n      return item ? JSON.parse(item) : null;\n    } catch (error) {\n      console.warn(`Failed to get ${key} from localStorage:`, error);\n      return null;\n    }\n  }\n\n  async set(key: string, value: any): Promise<void> {\n    try {\n      localStorage.setItem(key, JSON.stringify(value));\n    } catch (error) {\n      console.warn(`Failed to set ${key} in localStorage:`, error);\n      throw error;\n    }\n  }\n\n  async remove(key: string): Promise<void> {\n    try {\n      localStorage.removeItem(key);\n    } catch (error) {\n      console.warn(`Failed to remove ${key} from localStorage:`, error);\n    }\n  }\n\n  async clear(): Promise<void> {\n    try {\n      localStorage.clear();\n    } catch (error) {\n      console.warn('Failed to clear localStorage:', error);\n    }\n  }\n\n  async keys(): Promise<string[]> {\n    try {\n      return Object.keys(localStorage);\n    } catch (error) {\n      console.warn('Failed to get localStorage keys:', error);\n      return [];\n    }\n  }\n}\n\nclass IndexedDBAdapter implements StorageAdapter {\n  private dbName = 'TravelingAppDB';\n  private version = 1;\n  private storeName = 'keyvalue';\n  private db?: IDBDatabase;\n\n  private async getDB(): Promise<IDBDatabase> {\n    if (this.db) return this.db;\n\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.version);\n\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => {\n        this.db = request.result;\n        resolve(this.db);\n      };\n\n      request.onupgradeneeded = (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        if (!db.objectStoreNames.contains(this.storeName)) {\n          db.createObjectStore(this.storeName);\n        }\n      };\n    });\n  }\n\n  async get(key: string): Promise<any> {\n    try {\n      const db = await this.getDB();\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([this.storeName], 'readonly');\n        const store = transaction.objectStore(this.storeName);\n        const request = store.get(key);\n\n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => resolve(request.result);\n      });\n    } catch (error) {\n      console.warn(`Failed to get ${key} from IndexedDB:`, error);\n      return null;\n    }\n  }\n\n  async set(key: string, value: any): Promise<void> {\n    try {\n      const db = await this.getDB();\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([this.storeName], 'readwrite');\n        const store = transaction.objectStore(this.storeName);\n        const request = store.put(value, key);\n\n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => resolve();\n      });\n    } catch (error) {\n      console.warn(`Failed to set ${key} in IndexedDB:`, error);\n      throw error;\n    }\n  }\n\n  async remove(key: string): Promise<void> {\n    try {\n      const db = await this.getDB();\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([this.storeName], 'readwrite');\n        const store = transaction.objectStore(this.storeName);\n        const request = store.delete(key);\n\n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => resolve();\n      });\n    } catch (error) {\n      console.warn(`Failed to remove ${key} from IndexedDB:`, error);\n    }\n  }\n\n  async clear(): Promise<void> {\n    try {\n      const db = await this.getDB();\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([this.storeName], 'readwrite');\n        const store = transaction.objectStore(this.storeName);\n        const request = store.clear();\n\n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => resolve();\n      });\n    } catch (error) {\n      console.warn('Failed to clear IndexedDB:', error);\n    }\n  }\n\n  async keys(): Promise<string[]> {\n    try {\n      const db = await this.getDB();\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([this.storeName], 'readonly');\n        const store = transaction.objectStore(this.storeName);\n        const request = store.getAllKeys();\n\n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => resolve(request.result as string[]);\n      });\n    } catch (error) {\n      console.warn('Failed to get IndexedDB keys:', error);\n      return [];\n    }\n  }\n}\n\nclass MemoryAdapter implements StorageAdapter {\n  private data = new Map<string, any>();\n\n  async get(key: string): Promise<any> {\n    return this.data.get(key) || null;\n  }\n\n  async set(key: string, value: any): Promise<void> {\n    this.data.set(key, value);\n  }\n\n  async remove(key: string): Promise<void> {\n    this.data.delete(key);\n  }\n\n  async clear(): Promise<void> {\n    this.data.clear();\n  }\n\n  async keys(): Promise<string[]> {\n    return Array.from(this.data.keys());\n  }\n}\n\nclass StorageManager {\n  private adapter: StorageAdapter;\n\n  constructor() {\n    this.adapter = this.createAdapter();\n  }\n\n  private createAdapter(): StorageAdapter {\n    // Try IndexedDB first for large data\n    if (typeof indexedDB !== 'undefined') {\n      try {\n        return new IndexedDBAdapter();\n      } catch (error) {\n        console.warn('IndexedDB not available, falling back to localStorage');\n      }\n    }\n\n    // Fallback to localStorage\n    if (typeof localStorage !== 'undefined') {\n      try {\n        // Test localStorage availability\n        localStorage.setItem('__test__', 'test');\n        localStorage.removeItem('__test__');\n        return new LocalStorageAdapter();\n      } catch (error) {\n        console.warn('localStorage not available, falling back to memory storage');\n      }\n    }\n\n    // Final fallback to memory storage\n    return new MemoryAdapter();\n  }\n\n  async get(key: string): Promise<any> {\n    return this.adapter.get(key);\n  }\n\n  async set(key: string, value: any): Promise<void> {\n    return this.adapter.set(key, value);\n  }\n\n  async remove(key: string): Promise<void> {\n    return this.adapter.remove(key);\n  }\n\n  async clear(): Promise<void> {\n    return this.adapter.clear();\n  }\n\n  async keys(): Promise<string[]> {\n    return this.adapter.keys();\n  }\n\n  // Convenience methods\n  async getNumber(key: string, defaultValue = 0): Promise<number> {\n    const value = await this.get(key);\n    return typeof value === 'number' ? value : defaultValue;\n  }\n\n  async getString(key: string, defaultValue = ''): Promise<string> {\n    const value = await this.get(key);\n    return typeof value === 'string' ? value : defaultValue;\n  }\n\n  async getBoolean(key: string, defaultValue = false): Promise<boolean> {\n    const value = await this.get(key);\n    return typeof value === 'boolean' ? value : defaultValue;\n  }\n\n  async getArray<T>(key: string, defaultValue: T[] = []): Promise<T[]> {\n    const value = await this.get(key);\n    return Array.isArray(value) ? value : defaultValue;\n  }\n\n  async getObject<T>(key: string, defaultValue: T | null = null): Promise<T | null> {\n    const value = await this.get(key);\n    return value && typeof value === 'object' ? value : defaultValue;\n  }\n\n  // Batch operations\n  async setMany(items: Record<string, any>): Promise<void> {\n    await Promise.all(\n      Object.entries(items).map(([key, value]) => this.set(key, value))\n    );\n  }\n\n  async getMany(keys: string[]): Promise<Record<string, any>> {\n    const results = await Promise.all(\n      keys.map(async key => ({ key, value: await this.get(key) }))\n    );\n    \n    return results.reduce((acc, { key, value }) => {\n      acc[key] = value;\n      return acc;\n    }, {} as Record<string, any>);\n  }\n\n  // Cache with TTL\n  async setWithTTL(key: string, value: any, ttlMs: number): Promise<void> {\n    const expiry = Date.now() + ttlMs;\n    await this.set(key, { value, expiry });\n  }\n\n  async getWithTTL(key: string): Promise<any> {\n    const item = await this.get(key);\n    if (!item || typeof item !== 'object' || !item.expiry) {\n      return null;\n    }\n\n    if (Date.now() > item.expiry) {\n      await this.remove(key);\n      return null;\n    }\n\n    return item.value;\n  }\n}\n\n// Global storage instance\nexport const storage = new StorageManager();","import type { \n  TripPlan, \n  TripStop, \n  PlanningConstraints, \n  LatLng, \n  StopCategory,\n  Place \n} from '@/types';\nimport { AppError } from '@/types';\nimport { EventBus } from '@/lib/utils/events';\nimport { telemetry } from '@/lib/telemetry';\nimport { storage } from '@/lib/storage';\n\ninterface PlanValidationResult {\n  valid: boolean;\n  errors: string[];\n  warnings: string[];\n}\n\nclass PlanningManager extends EventBus {\n  private currentPlan?: TripPlan;\n  private plans = new Map<string, TripPlan>();\n\n  constructor() {\n    super();\n    this.loadPlans();\n  }\n\n  async createPlan(\n    name: string,\n    description?: string,\n    startDate?: Date,\n    endDate?: Date\n  ): Promise<TripPlan> {\n    const plan: TripPlan = {\n      id: this.generateId(),\n      name,\n      description,\n      startDate: startDate || new Date(),\n      endDate: endDate || new Date(Date.now() + 24 * 60 * 60 * 1000), // Default: 1 day\n      stops: [],\n      metadata: {\n        created: new Date(),\n        updated: new Date(),\n        version: 1\n      }\n    };\n\n    this.plans.set(plan.id, plan);\n    this.currentPlan = plan;\n    await this.savePlans();\n\n    telemetry.track('trip_plan_created', {\n      plan_id: plan.id,\n      has_description: !!description,\n      duration_days: Math.ceil((plan.endDate.getTime() - plan.startDate.getTime()) / (24 * 60 * 60 * 1000))\n    });\n\n    this.emit('plan-created', plan);\n    return plan;\n  }\n\n  async updatePlan(planId: string, updates: Partial<TripPlan>): Promise<TripPlan> {\n    const plan = this.plans.get(planId);\n    if (!plan) {\n      throw new AppError('Trip plan not found', 'PLAN_NOT_FOUND');\n    }\n\n    const updatedPlan: TripPlan = {\n      ...plan,\n      ...updates,\n      id: plan.id, // Ensure ID cannot be changed\n      metadata: {\n        ...plan.metadata,\n        updated: new Date(),\n        version: plan.metadata.version + 1\n      }\n    };\n\n    // Validate the updated plan\n    const validation = this.validatePlan(updatedPlan);\n    if (!validation.valid) {\n      throw new AppError(\n        `Plan validation failed: ${validation.errors.join(', ')}`,\n        'PLAN_VALIDATION_FAILED'\n      );\n    }\n\n    this.plans.set(planId, updatedPlan);\n    if (this.currentPlan?.id === planId) {\n      this.currentPlan = updatedPlan;\n    }\n    await this.savePlans();\n\n    telemetry.track('trip_plan_updated', {\n      plan_id: planId,\n      stops_count: updatedPlan.stops.length,\n      has_route: !!updatedPlan.route\n    });\n\n    this.emit('plan-updated', updatedPlan);\n    return updatedPlan;\n  }\n\n  async deletePlan(planId: string): Promise<void> {\n    const plan = this.plans.get(planId);\n    if (!plan) {\n      throw new AppError('Trip plan not found', 'PLAN_NOT_FOUND');\n    }\n\n    this.plans.delete(planId);\n    if (this.currentPlan?.id === planId) {\n      this.currentPlan = undefined;\n    }\n    await this.savePlans();\n\n    telemetry.track('trip_plan_deleted', { plan_id: planId });\n    this.emit('plan-deleted', planId);\n  }\n\n  async addStop(\n    planId: string,\n    place: Place,\n    options: {\n      category: StopCategory;\n      priority?: number;\n      arrivalTime?: Date;\n      departureTime?: Date;\n      duration?: number;\n      notes?: string;\n      weatherDependent?: boolean;\n      insertIndex?: number;\n    }\n  ): Promise<TripStop> {\n    const plan = this.plans.get(planId);\n    if (!plan) {\n      throw new AppError('Trip plan not found', 'PLAN_NOT_FOUND');\n    }\n\n    const stop: TripStop = {\n      id: this.generateId(),\n      place,\n      category: options.category,\n      priority: options.priority || 3,\n      arrivalTime: options.arrivalTime,\n      departureTime: options.departureTime,\n      duration: options.duration,\n      notes: options.notes,\n      weatherDependent: options.weatherDependent || false\n    };\n\n    // Insert at specified index or append\n    if (options.insertIndex !== undefined && options.insertIndex >= 0) {\n      plan.stops.splice(options.insertIndex, 0, stop);\n    } else {\n      plan.stops.push(stop);\n    }\n\n    await this.updatePlan(planId, { stops: plan.stops });\n\n    telemetry.track('trip_stop_added', {\n      plan_id: planId,\n      stop_id: stop.id,\n      category: stop.category,\n      has_timing: !!(stop.arrivalTime || stop.departureTime),\n      weather_dependent: stop.weatherDependent\n    });\n\n    this.emit('stop-added', { planId, stop });\n    return stop;\n  }\n\n  async updateStop(\n    planId: string,\n    stopId: string,\n    updates: Partial<TripStop>\n  ): Promise<TripStop> {\n    const plan = this.plans.get(planId);\n    if (!plan) {\n      throw new AppError('Trip plan not found', 'PLAN_NOT_FOUND');\n    }\n\n    const stopIndex = plan.stops.findIndex(s => s.id === stopId);\n    if (stopIndex === -1) {\n      throw new AppError('Stop not found', 'STOP_NOT_FOUND');\n    }\n\n    const updatedStop: TripStop = {\n      ...plan.stops[stopIndex],\n      ...updates,\n      id: stopId // Ensure ID cannot be changed\n    };\n\n    plan.stops[stopIndex] = updatedStop;\n    await this.updatePlan(planId, { stops: plan.stops });\n\n    telemetry.track('trip_stop_updated', {\n      plan_id: planId,\n      stop_id: stopId\n    });\n\n    this.emit('stop-updated', { planId, stop: updatedStop });\n    return updatedStop;\n  }\n\n  async removeStop(planId: string, stopId: string): Promise<void> {\n    const plan = this.plans.get(planId);\n    if (!plan) {\n      throw new AppError('Trip plan not found', 'PLAN_NOT_FOUND');\n    }\n\n    const stopIndex = plan.stops.findIndex(s => s.id === stopId);\n    if (stopIndex === -1) {\n      throw new AppError('Stop not found', 'STOP_NOT_FOUND');\n    }\n\n    plan.stops.splice(stopIndex, 1);\n    await this.updatePlan(planId, { stops: plan.stops });\n\n    telemetry.track('trip_stop_removed', {\n      plan_id: planId,\n      stop_id: stopId\n    });\n\n    this.emit('stop-removed', { planId, stopId });\n  }\n\n  async reorderStops(planId: string, fromIndex: number, toIndex: number): Promise<void> {\n    const plan = this.plans.get(planId);\n    if (!plan) {\n      throw new AppError('Trip plan not found', 'PLAN_NOT_FOUND');\n    }\n\n    if (fromIndex < 0 || fromIndex >= plan.stops.length ||\n        toIndex < 0 || toIndex >= plan.stops.length) {\n      throw new AppError('Invalid stop indices', 'INVALID_INDICES');\n    }\n\n    const [movedStop] = plan.stops.splice(fromIndex, 1);\n    plan.stops.splice(toIndex, 0, movedStop);\n\n    await this.updatePlan(planId, { stops: plan.stops });\n\n    telemetry.track('trip_stops_reordered', {\n      plan_id: planId,\n      from_index: fromIndex,\n      to_index: toIndex\n    });\n\n    this.emit('stops-reordered', { planId, fromIndex, toIndex });\n  }\n\n  validatePlan(plan: TripPlan): PlanValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    // Basic validation\n    if (!plan.name.trim()) {\n      errors.push('Plan name is required');\n    }\n\n    if (plan.endDate <= plan.startDate) {\n      errors.push('End date must be after start date');\n    }\n\n    // Stop validation\n    for (let i = 0; i < plan.stops.length; i++) {\n      const stop = plan.stops[i];\n      const stopPrefix = `Stop ${i + 1}`;\n\n      if (!stop.place.name) {\n        errors.push(`${stopPrefix}: Place name is required`);\n      }\n\n      if (!stop.place.location.lat || !stop.place.location.lng) {\n        errors.push(`${stopPrefix}: Valid location coordinates are required`);\n      }\n\n      // Time validation\n      if (stop.arrivalTime && stop.departureTime) {\n        if (stop.departureTime <= stop.arrivalTime) {\n          errors.push(`${stopPrefix}: Departure time must be after arrival time`);\n        }\n\n        const actualDuration = stop.departureTime.getTime() - stop.arrivalTime.getTime();\n        const expectedDuration = (stop.duration || 60) * 60 * 1000; // Convert minutes to ms\n\n        if (Math.abs(actualDuration - expectedDuration) > 30 * 60 * 1000) { // 30 min tolerance\n          warnings.push(`${stopPrefix}: Duration mismatch between times and specified duration`);\n        }\n      }\n\n      // Check for overlapping times with next stop\n      if (i < plan.stops.length - 1) {\n        const nextStop = plan.stops[i + 1];\n        if (stop.departureTime && nextStop.arrivalTime) {\n          if (stop.departureTime > nextStop.arrivalTime) {\n            errors.push(`${stopPrefix}: Departure time overlaps with next stop's arrival time`);\n          }\n        }\n      }\n\n      // Realistic duration validation\n      if (stop.duration) {\n        const maxDurations: Record<StopCategory, number> = {\n          meal: 180,        // 3 hours max\n          scenic: 120,      // 2 hours max\n          activity: 480,    // 8 hours max\n          accommodation: 720, // 12 hours max (half day)\n          fuel: 30,         // 30 minutes max\n          shopping: 240,    // 4 hours max\n          cultural: 360,    // 6 hours max\n          other: 480        // 8 hours max\n        };\n\n        const maxDuration = maxDurations[stop.category];\n        if (stop.duration > maxDuration) {\n          warnings.push(`${stopPrefix}: Duration (${stop.duration} min) seems unusually long for ${stop.category}`);\n        }\n\n        if (stop.duration < 5 && stop.category !== 'fuel') {\n          warnings.push(`${stopPrefix}: Duration (${stop.duration} min) seems too short`);\n        }\n      }\n    }\n\n    // Check total trip duration\n    const totalDays = Math.ceil((plan.endDate.getTime() - plan.startDate.getTime()) / (24 * 60 * 60 * 1000));\n    if (totalDays > 30) {\n      warnings.push('Trip duration is very long (> 30 days)');\n    }\n\n    // Check for reasonable number of stops per day\n    const stopsPerDay = plan.stops.length / totalDays;\n    if (stopsPerDay > 10) {\n      warnings.push('Very high number of stops per day - consider reducing for a more relaxed trip');\n    }\n\n    return {\n      valid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  optimizeStopOrder(planId: string, constraints?: PlanningConstraints): Promise<TripPlan> {\n    // This would implement a traveling salesman problem solver\n    // For now, return a simple implementation\n    return Promise.resolve(this.plans.get(planId)!);\n  }\n\n  getPlan(planId: string): TripPlan | undefined {\n    return this.plans.get(planId);\n  }\n\n  getCurrentPlan(): TripPlan | undefined {\n    return this.currentPlan;\n  }\n\n  getAllPlans(): TripPlan[] {\n    return Array.from(this.plans.values()).sort(\n      (a, b) => b.metadata.updated.getTime() - a.metadata.updated.getTime()\n    );\n  }\n\n  setCurrentPlan(planId: string): void {\n    const plan = this.plans.get(planId);\n    if (plan) {\n      this.currentPlan = plan;\n      this.emit('current-plan-changed', plan);\n    }\n  }\n\n  private generateId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private async loadPlans(): Promise<void> {\n    try {\n      const saved = await storage.get('trip-plans') as TripPlan[] || [];\n      saved.forEach(plan => {\n        // Deserialize dates\n        plan.startDate = new Date(plan.startDate);\n        plan.endDate = new Date(plan.endDate);\n        plan.metadata.created = new Date(plan.metadata.created);\n        plan.metadata.updated = new Date(plan.metadata.updated);\n        \n        plan.stops.forEach(stop => {\n          if (stop.arrivalTime) stop.arrivalTime = new Date(stop.arrivalTime);\n          if (stop.departureTime) stop.departureTime = new Date(stop.departureTime);\n        });\n\n        this.plans.set(plan.id, plan);\n      });\n\n      const currentPlanId = await storage.get('current-plan-id') as string;\n      if (currentPlanId) {\n        this.currentPlan = this.plans.get(currentPlanId);\n      }\n    } catch (error) {\n      console.warn('Failed to load plans:', error);\n    }\n  }\n\n  private async savePlans(): Promise<void> {\n    try {\n      const plans = Array.from(this.plans.values());\n      await storage.set('trip-plans', plans);\n      \n      if (this.currentPlan) {\n        await storage.set('current-plan-id', this.currentPlan.id);\n      }\n    } catch (error) {\n      console.warn('Failed to save plans:', error);\n    }\n  }\n}\n\n// Global singleton\nexport const planningManager = new PlanningManager();\n\n// Hook for easier usage\nexport function usePlanning() {\n  return {\n    createPlan: planningManager.createPlan.bind(planningManager),\n    updatePlan: planningManager.updatePlan.bind(planningManager),\n    deletePlan: planningManager.deletePlan.bind(planningManager),\n    addStop: planningManager.addStop.bind(planningManager),\n    updateStop: planningManager.updateStop.bind(planningManager),\n    removeStop: planningManager.removeStop.bind(planningManager),\n    reorderStops: planningManager.reorderStops.bind(planningManager),\n    validatePlan: planningManager.validatePlan.bind(planningManager),\n    optimizeStopOrder: planningManager.optimizeStopOrder.bind(planningManager),\n    getPlan: planningManager.getPlan.bind(planningManager),\n    getCurrentPlan: planningManager.getCurrentPlan.bind(planningManager),\n    getAllPlans: planningManager.getAllPlans.bind(planningManager),\n    setCurrentPlan: planningManager.setCurrentPlan.bind(planningManager),\n    subscribe: (event: string, callback: Function) => {\n      planningManager.on(event, callback);\n      return () => planningManager.off(event, callback);\n    }\n  };\n}","import type { VoiceIntent } from '@/types';\nimport { AppError } from '@/types';\nimport { EventBus } from '@/lib/utils/events';\nimport { telemetry } from '@/lib/telemetry';\n\ninterface VoiceConfig {\n  language: string;\n  continuous: boolean;\n  interimResults: boolean;\n  maxAlternatives: number;\n}\n\ninterface STTProvider {\n  startListening(): Promise<void>;\n  stopListening(): Promise<void>;\n  isListening(): boolean;\n  isSupported(): boolean;\n}\n\nclass WebSpeechSTTProvider implements STTProvider {\n  private recognition?: SpeechRecognition;\n  private isActive = false;\n  private config: VoiceConfig;\n  private eventBus: EventBus;\n\n  constructor(config: VoiceConfig, eventBus: EventBus) {\n    this.config = config;\n    this.eventBus = eventBus;\n    this.initializeRecognition();\n  }\n\n  private initializeRecognition(): void {\n    if (!this.isSupported()) return;\n\n    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n    this.recognition = new SpeechRecognition();\n    \n    this.recognition.continuous = this.config.continuous;\n    this.recognition.interimResults = this.config.interimResults;\n    this.recognition.lang = this.config.language;\n    this.recognition.maxAlternatives = this.config.maxAlternatives;\n\n    this.recognition.onstart = () => {\n      this.isActive = true;\n      this.eventBus.emit('stt-started');\n      telemetry.track('voice_recognition_started');\n    };\n\n    this.recognition.onend = () => {\n      this.isActive = false;\n      this.eventBus.emit('stt-ended');\n      telemetry.track('voice_recognition_ended');\n    };\n\n    this.recognition.onresult = (event) => {\n      const results = Array.from(event.results);\n      const transcript = results\n        .map(result => result[0].transcript)\n        .join(' ');\n\n      const confidence = results.length > 0 ? results[0][0].confidence : 0;\n      \n      this.eventBus.emit('stt-result', { transcript, confidence });\n      telemetry.track('voice_recognition_result', {\n        transcript_length: transcript.length,\n        confidence,\n        is_final: event.results[event.results.length - 1].isFinal\n      });\n    };\n\n    this.recognition.onerror = (event) => {\n      this.isActive = false;\n      this.eventBus.emit('stt-error', event.error);\n      telemetry.track('voice_recognition_error', { error: event.error });\n    };\n  }\n\n  async startListening(): Promise<void> {\n    if (!this.recognition || this.isActive) return;\n\n    try {\n      this.recognition.start();\n    } catch (error) {\n      throw new AppError('Failed to start speech recognition', 'STT_START_FAILED');\n    }\n  }\n\n  async stopListening(): Promise<void> {\n    if (!this.recognition || !this.isActive) return;\n\n    this.recognition.stop();\n  }\n\n  isListening(): boolean {\n    return this.isActive;\n  }\n\n  isSupported(): boolean {\n    return !!(window.SpeechRecognition || window.webkitSpeechRecognition);\n  }\n}\n\ninterface IntentParser {\n  parse(transcript: string): Promise<VoiceIntent>;\n}\n\nclass SimpleLinguisticParser implements IntentParser {\n  private patterns = {\n    plan_create: [\n      /plan.*trip.*to\\s+(.+)/i,\n      /create.*plan.*for\\s+(.+)/i,\n      /תכנן.*טיול.*ל(.+)/i,\n      /צור.*תוכנית.*ל(.+)/i\n    ],\n    plan_update: [\n      /add.*stop.*at\\s+(.+)/i,\n      /include.*(.+).*in.*plan/i,\n      /הוסף.*עצירה.*ב(.+)/i,\n      /כלול.*(.+).*בתוכנית/i\n    ],\n    search: [\n      /find.*(.+)/i,\n      /search.*for\\s+(.+)/i,\n      /look.*for\\s+(.+)/i,\n      /מצא.*(.+)/i,\n      /חפש.*(.+)/i\n    ],\n    navigate: [\n      /navigate.*to\\s+(.+)/i,\n      /directions.*to\\s+(.+)/i,\n      /go.*to\\s+(.+)/i,\n      /נווט.*ל(.+)/i,\n      /הוראות.*ל(.+)/i\n    ],\n    weather: [\n      /weather.*(?:in|at|for)\\s+(.+)/i,\n      /מזג.*אוויר.*ב(.+)/i\n    ]\n  };\n\n  async parse(transcript: string): Promise<VoiceIntent> {\n    const normalizedTranscript = transcript.trim().toLowerCase();\n    \n    for (const [intentType, patterns] of Object.entries(this.patterns)) {\n      for (const pattern of patterns) {\n        const match = normalizedTranscript.match(pattern);\n        if (match) {\n          return {\n            type: intentType as VoiceIntent['type'],\n            confidence: 0.8,\n            parameters: this.extractParameters(intentType, match),\n            original: transcript\n          };\n        }\n      }\n    }\n\n    // Fallback to search intent\n    return {\n      type: 'search',\n      confidence: 0.5,\n      parameters: { query: transcript },\n      original: transcript\n    };\n  }\n\n  private extractParameters(intentType: string, match: RegExpMatchArray): Record<string, any> {\n    const captured = match[1] || '';\n    \n    switch (intentType) {\n      case 'plan_create':\n        return { destination: captured.trim() };\n      case 'plan_update':\n        return { place: captured.trim() };\n      case 'search':\n      case 'navigate':\n        return { query: captured.trim() };\n      case 'weather':\n        return { location: captured.trim() };\n      default:\n        return { text: captured.trim() };\n    }\n  }\n}\n\nclass VoiceManager extends EventBus {\n  private sttProvider: STTProvider;\n  private intentParser: IntentParser;\n  private isInitialized = false;\n\n  constructor() {\n    super();\n    \n    const config: VoiceConfig = {\n      language: 'he-IL', // Hebrew support\n      continuous: false,\n      interimResults: true,\n      maxAlternatives: 3\n    };\n\n    this.sttProvider = new WebSpeechSTTProvider(config, this);\n    this.intentParser = new SimpleLinguisticParser();\n    \n    this.setupEventHandlers();\n  }\n\n  private setupEventHandlers(): void {\n    this.on('stt-result', async ({ transcript, confidence }) => {\n      try {\n        const intent = await this.intentParser.parse(transcript);\n        this.emit('intent-recognized', intent);\n        \n        telemetry.track('voice_intent_recognized', {\n          intent_type: intent.type,\n          confidence: intent.confidence,\n          has_parameters: Object.keys(intent.parameters).length > 0\n        });\n      } catch (error) {\n        console.error('Intent parsing failed:', error);\n        this.emit('intent-error', error);\n      }\n    });\n\n    this.on('stt-error', (error) => {\n      this.emit('voice-error', new AppError(`Speech recognition error: ${error}`, 'STT_ERROR'));\n    });\n  }\n\n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    if (!this.sttProvider.isSupported()) {\n      throw new AppError('Speech recognition not supported', 'STT_NOT_SUPPORTED');\n    }\n\n    this.isInitialized = true;\n    telemetry.track('voice_manager_initialized');\n  }\n\n  async startListening(): Promise<void> {\n    await this.initialize();\n    await this.sttProvider.startListening();\n    this.emit('listening-started');\n  }\n\n  async stopListening(): Promise<void> {\n    await this.sttProvider.stopListening();\n    this.emit('listening-stopped');\n  }\n\n  isListening(): boolean {\n    return this.sttProvider.isListening();\n  }\n\n  isSupported(): boolean {\n    return this.sttProvider.isSupported();\n  }\n\n  // Text-to-Speech functionality\n  speak(text: string, options: {\n    language?: string;\n    rate?: number;\n    pitch?: number;\n    volume?: number;\n  } = {}): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (!('speechSynthesis' in window)) {\n        reject(new AppError('Text-to-speech not supported', 'TTS_NOT_SUPPORTED'));\n        return;\n      }\n\n      const utterance = new SpeechSynthesisUtterance(text);\n      utterance.lang = options.language || 'he-IL';\n      utterance.rate = options.rate || 0.9;\n      utterance.pitch = options.pitch || 1.0;\n      utterance.volume = options.volume || 0.8;\n\n      utterance.onend = () => {\n        telemetry.track('voice_tts_completed', { text_length: text.length });\n        resolve();\n      };\n\n      utterance.onerror = (event) => {\n        telemetry.track('voice_tts_error', { error: event.error });\n        reject(new AppError(`Text-to-speech error: ${event.error}`, 'TTS_ERROR'));\n      };\n\n      speechSynthesis.speak(utterance);\n      telemetry.track('voice_tts_started', { text_length: text.length });\n    });\n  }\n\n  stopSpeaking(): void {\n    if ('speechSynthesis' in window) {\n      speechSynthesis.cancel();\n    }\n  }\n\n  isSpeaking(): boolean {\n    return 'speechSynthesis' in window && speechSynthesis.speaking;\n  }\n\n  // Press and hold interface\n  async startPressAndHold(): Promise<void> {\n    await this.startListening();\n    // Visual feedback for press and hold\n    document.body.classList.add('voice-listening');\n  }\n\n  async endPressAndHold(): Promise<void> {\n    await this.stopListening();\n    document.body.classList.remove('voice-listening');\n  }\n\n  // Quick voice commands\n  async processQuickCommand(command: string): Promise<VoiceIntent> {\n    const intent = await this.intentParser.parse(command);\n    this.emit('intent-recognized', intent);\n    return intent;\n  }\n}\n\n// Global voice manager instance\nexport const voiceManager = new VoiceManager();\n\n// Hook for easier usage\nexport function useVoice() {\n  return {\n    startListening: voiceManager.startListening.bind(voiceManager),\n    stopListening: voiceManager.stopListening.bind(voiceManager),\n    isListening: voiceManager.isListening.bind(voiceManager),\n    isSupported: voiceManager.isSupported.bind(voiceManager),\n    speak: voiceManager.speak.bind(voiceManager),\n    stopSpeaking: voiceManager.stopSpeaking.bind(voiceManager),\n    isSpeaking: voiceManager.isSpeaking.bind(voiceManager),\n    startPressAndHold: voiceManager.startPressAndHold.bind(voiceManager),\n    endPressAndHold: voiceManager.endPressAndHold.bind(voiceManager),\n    processQuickCommand: voiceManager.processQuickCommand.bind(voiceManager),\n    subscribe: (event: string, callback: Function) => {\n      voiceManager.on(event, callback);\n      return () => voiceManager.off(event, callback);\n    }\n  };\n}\n\n// Extend window interface for TypeScript\ndeclare global {\n  interface Window {\n    SpeechRecognition: typeof SpeechRecognition;\n    webkitSpeechRecognition: typeof SpeechRecognition;\n  }\n}","import type { Route, RouteLeg, RouteStep, LatLng, TripPlan } from '@/types';\nimport { AppError } from '@/types';\nimport { EventBus } from '@/lib/utils/events';\nimport { telemetry } from '@/lib/telemetry';\n\ninterface NavigationState {\n  isNavigating: boolean;\n  currentRoute?: Route;\n  currentLeg: number;\n  currentStep: number;\n  currentLocation?: LatLng;\n  nextInstruction?: RouteStep;\n  distanceToNextStep: number;\n  estimatedTimeRemaining: number;\n}\n\ninterface NavigationSettings {\n  voiceGuidance: boolean;\n  units: 'metric' | 'imperial';\n  avoidTolls: boolean;\n  routePreference: 'fastest' | 'shortest' | 'scenic';\n}\n\nclass NavigationManager extends EventBus {\n  private state: NavigationState = {\n    isNavigating: false,\n    currentLeg: 0,\n    currentStep: 0,\n    distanceToNextStep: 0,\n    estimatedTimeRemaining: 0\n  };\n\n  private settings: NavigationSettings = {\n    voiceGuidance: true,\n    units: 'metric',\n    avoidTolls: false,\n    routePreference: 'fastest'\n  };\n\n  private watchId?: number;\n  private lastAnnouncedStep = -1;\n\n  constructor() {\n    super();\n    this.loadSettings();\n  }\n\n  async startNavigation(route: Route, startFromStep = 0): Promise<void> {\n    try {\n      this.state = {\n        isNavigating: true,\n        currentRoute: route,\n        currentLeg: 0,\n        currentStep: startFromStep,\n        distanceToNextStep: 0,\n        estimatedTimeRemaining: route.overview.duration\n      };\n\n      await this.startLocationTracking();\n      this.emit('navigation-started', this.state);\n      \n      telemetry.track('navigation_started', {\n        total_distance: route.overview.distance,\n        total_duration: route.overview.duration,\n        legs_count: route.legs.length\n      });\n\n      // Announce first instruction\n      if (this.settings.voiceGuidance) {\n        this.announceNextInstruction();\n      }\n    } catch (error) {\n      telemetry.track('navigation_start_error', {\n        error: error instanceof Error ? error.message : 'Unknown error'\n      });\n      throw error;\n    }\n  }\n\n  async stopNavigation(): Promise<void> {\n    this.state.isNavigating = false;\n    this.stopLocationTracking();\n    this.emit('navigation-stopped');\n    \n    telemetry.track('navigation_stopped', {\n      was_completed: this.isNavigationComplete()\n    });\n  }\n\n  async pauseNavigation(): Promise<void> {\n    this.stopLocationTracking();\n    this.emit('navigation-paused');\n    telemetry.track('navigation_paused');\n  }\n\n  async resumeNavigation(): Promise<void> {\n    if (!this.state.currentRoute) {\n      throw new AppError('No active route to resume', 'NO_ACTIVE_ROUTE');\n    }\n\n    await this.startLocationTracking();\n    this.emit('navigation-resumed');\n    telemetry.track('navigation_resumed');\n  }\n\n  private async startLocationTracking(): Promise<void> {\n    if (!navigator.geolocation) {\n      throw new AppError('Geolocation not supported', 'GEOLOCATION_NOT_SUPPORTED');\n    }\n\n    return new Promise((resolve, reject) => {\n      const options: PositionOptions = {\n        enableHighAccuracy: true,\n        timeout: 10000,\n        maximumAge: 1000\n      };\n\n      // Get initial position\n      navigator.geolocation.getCurrentPosition(\n        (position) => {\n          this.updateLocation({\n            lat: position.coords.latitude,\n            lng: position.coords.longitude\n          });\n          \n          // Start watching position\n          this.watchId = navigator.geolocation.watchPosition(\n            (position) => {\n              this.updateLocation({\n                lat: position.coords.latitude,\n                lng: position.coords.longitude\n              });\n            },\n            (error) => {\n              console.error('Location tracking error:', error);\n              this.emit('navigation-error', new AppError(\n                `Location tracking failed: ${error.message}`,\n                'LOCATION_TRACKING_FAILED'\n              ));\n            },\n            options\n          );\n          \n          resolve();\n        },\n        (error) => {\n          reject(new AppError(\n            `Failed to get initial location: ${error.message}`,\n            'INITIAL_LOCATION_FAILED'\n          ));\n        },\n        options\n      );\n    });\n  }\n\n  private stopLocationTracking(): void {\n    if (this.watchId !== undefined) {\n      navigator.geolocation.clearWatch(this.watchId);\n      this.watchId = undefined;\n    }\n  }\n\n  private updateLocation(location: LatLng): void {\n    this.state.currentLocation = location;\n    \n    if (!this.state.currentRoute || !this.state.isNavigating) return;\n\n    // Update navigation state based on current location\n    this.updateNavigationProgress(location);\n    this.emit('location-updated', { location, state: this.state });\n  }\n\n  private updateNavigationProgress(location: LatLng): void {\n    if (!this.state.currentRoute) return;\n\n    const currentLeg = this.state.currentRoute.legs[this.state.currentLeg];\n    if (!currentLeg) return;\n\n    const currentStep = currentLeg.steps[this.state.currentStep];\n    if (!currentStep) return;\n\n    // Calculate distance to next step\n    this.state.distanceToNextStep = this.calculateDistance(location, currentStep.end);\n\n    // Check if we've reached the current step\n    if (this.state.distanceToNextStep < 20) { // 20 meters threshold\n      this.advanceToNextStep();\n    }\n\n    // Update estimated time remaining\n    this.updateEstimatedTime();\n\n    // Check for voice announcements\n    this.checkVoiceAnnouncements();\n  }\n\n  private advanceToNextStep(): void {\n    if (!this.state.currentRoute) return;\n\n    const currentLeg = this.state.currentRoute.legs[this.state.currentLeg];\n    if (!currentLeg) return;\n\n    this.state.currentStep++;\n\n    // Check if we've completed the current leg\n    if (this.state.currentStep >= currentLeg.steps.length) {\n      this.state.currentLeg++;\n      this.state.currentStep = 0;\n\n      // Check if we've completed the entire route\n      if (this.state.currentLeg >= this.state.currentRoute.legs.length) {\n        this.completeNavigation();\n        return;\n      }\n\n      this.emit('leg-completed', {\n        completedLeg: this.state.currentLeg - 1,\n        currentLeg: this.state.currentLeg\n      });\n    }\n\n    // Announce next instruction\n    if (this.settings.voiceGuidance) {\n      this.announceNextInstruction();\n    }\n\n    this.emit('step-advanced', this.state);\n    telemetry.track('navigation_step_advanced', {\n      leg: this.state.currentLeg,\n      step: this.state.currentStep\n    });\n  }\n\n  private completeNavigation(): void {\n    this.state.isNavigating = false;\n    this.stopLocationTracking();\n    \n    this.emit('navigation-completed');\n    telemetry.track('navigation_completed', {\n      total_legs: this.state.currentRoute?.legs.length,\n      final_leg: this.state.currentLeg,\n      final_step: this.state.currentStep\n    });\n\n    if (this.settings.voiceGuidance) {\n      this.speak('You have arrived at your destination!');\n    }\n  }\n\n  private updateEstimatedTime(): void {\n    if (!this.state.currentRoute) return;\n\n    // Calculate remaining time based on remaining distance and average speed\n    let remainingDistance = 0;\n    \n    // Add distance from current location to end of current step\n    remainingDistance += this.state.distanceToNextStep;\n    \n    // Add distance for remaining steps in current leg\n    const currentLeg = this.state.currentRoute.legs[this.state.currentLeg];\n    if (currentLeg) {\n      for (let i = this.state.currentStep + 1; i < currentLeg.steps.length; i++) {\n        remainingDistance += currentLeg.steps[i].distance;\n      }\n    }\n    \n    // Add distance for remaining legs\n    for (let i = this.state.currentLeg + 1; i < this.state.currentRoute.legs.length; i++) {\n      remainingDistance += this.state.currentRoute.legs[i].distance;\n    }\n\n    // Estimate time based on average speed (assuming 50 km/h average)\n    const averageSpeedMs = 50 * 1000 / 3600; // 50 km/h to m/s\n    this.state.estimatedTimeRemaining = Math.round(remainingDistance / averageSpeedMs);\n  }\n\n  private checkVoiceAnnouncements(): void {\n    if (!this.settings.voiceGuidance) return;\n    if (!this.state.currentRoute) return;\n\n    const currentLeg = this.state.currentRoute.legs[this.state.currentLeg];\n    if (!currentLeg) return;\n\n    const currentStep = currentLeg.steps[this.state.currentStep];\n    if (!currentStep) return;\n\n    // Announce at different distances\n    const distance = this.state.distanceToNextStep;\n    \n    if (distance <= 100 && this.lastAnnouncedStep !== this.state.currentStep) {\n      this.announceNextInstruction();\n      this.lastAnnouncedStep = this.state.currentStep;\n    }\n  }\n\n  private announceNextInstruction(): void {\n    if (!this.state.currentRoute) return;\n\n    const currentLeg = this.state.currentRoute.legs[this.state.currentLeg];\n    if (!currentLeg) return;\n\n    const nextStepIndex = this.state.currentStep + 1;\n    const nextStep = currentLeg.steps[nextStepIndex];\n    \n    if (nextStep) {\n      const distance = this.formatDistance(this.state.distanceToNextStep);\n      const instruction = `In ${distance}, ${nextStep.instruction}`;\n      this.speak(instruction);\n    }\n  }\n\n  private speak(text: string): void {\n    if ('speechSynthesis' in window) {\n      const utterance = new SpeechSynthesisUtterance(text);\n      utterance.rate = 0.9;\n      utterance.volume = 0.8;\n      speechSynthesis.speak(utterance);\n    }\n  }\n\n  private formatDistance(meters: number): string {\n    if (this.settings.units === 'imperial') {\n      const feet = meters * 3.28084;\n      if (feet < 1000) {\n        return `${Math.round(feet)} feet`;\n      } else {\n        const miles = feet / 5280;\n        return `${miles.toFixed(1)} miles`;\n      }\n    } else {\n      if (meters < 1000) {\n        return `${Math.round(meters)} meters`;\n      } else {\n        const km = meters / 1000;\n        return `${km.toFixed(1)} kilometers`;\n      }\n    }\n  }\n\n  private calculateDistance(from: LatLng, to: LatLng): number {\n    const R = 6371e3; // Earth's radius in meters\n    const φ1 = from.lat * Math.PI / 180;\n    const φ2 = to.lat * Math.PI / 180;\n    const Δφ = (to.lat - from.lat) * Math.PI / 180;\n    const Δλ = (to.lng - from.lng) * Math.PI / 180;\n\n    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +\n              Math.cos(φ1) * Math.cos(φ2) *\n              Math.sin(Δλ/2) * Math.sin(Δλ/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n\n    return R * c;\n  }\n\n  // Public API methods\n  getState(): NavigationState {\n    return { ...this.state };\n  }\n\n  getCurrentInstruction(): string {\n    if (!this.state.currentRoute) return '';\n\n    const currentLeg = this.state.currentRoute.legs[this.state.currentLeg];\n    if (!currentLeg) return '';\n\n    const currentStep = currentLeg.steps[this.state.currentStep];\n    return currentStep?.instruction || '';\n  }\n\n  getUpcomingInstructions(count = 3): RouteStep[] {\n    if (!this.state.currentRoute) return [];\n\n    const currentLeg = this.state.currentRoute.legs[this.state.currentLeg];\n    if (!currentLeg) return [];\n\n    const upcoming: RouteStep[] = [];\n    let stepIndex = this.state.currentStep + 1;\n    let legIndex = this.state.currentLeg;\n\n    while (upcoming.length < count && legIndex < this.state.currentRoute.legs.length) {\n      const leg = this.state.currentRoute.legs[legIndex];\n      \n      if (stepIndex < leg.steps.length) {\n        upcoming.push(leg.steps[stepIndex]);\n        stepIndex++;\n      } else {\n        legIndex++;\n        stepIndex = 0;\n      }\n    }\n\n    return upcoming;\n  }\n\n  updateSettings(newSettings: Partial<NavigationSettings>): void {\n    this.settings = { ...this.settings, ...newSettings };\n    this.saveSettings();\n    this.emit('settings-updated', this.settings);\n  }\n\n  getSettings(): NavigationSettings {\n    return { ...this.settings };\n  }\n\n  private loadSettings(): void {\n    try {\n      const saved = localStorage.getItem('navigation-settings');\n      if (saved) {\n        this.settings = { ...this.settings, ...JSON.parse(saved) };\n      }\n    } catch (error) {\n      console.warn('Failed to load navigation settings:', error);\n    }\n  }\n\n  private saveSettings(): void {\n    try {\n      localStorage.setItem('navigation-settings', JSON.stringify(this.settings));\n    } catch (error) {\n      console.warn('Failed to save navigation settings:', error);\n    }\n  }\n\n  isNavigationComplete(): boolean {\n    if (!this.state.currentRoute) return false;\n    return this.state.currentLeg >= this.state.currentRoute.legs.length;\n  }\n\n  // Simulation methods for testing\n  simulateLocation(location: LatLng): void {\n    if (import.meta.env.DEV) {\n      this.updateLocation(location);\n    }\n  }\n\n  simulateProgress(legIndex: number, stepIndex: number): void {\n    if (import.meta.env.DEV) {\n      this.state.currentLeg = legIndex;\n      this.state.currentStep = stepIndex;\n      this.emit('step-advanced', this.state);\n    }\n  }\n}\n\n// Global navigation manager\nexport const navigationManager = new NavigationManager();\n\n// Hook for easier usage\nexport function useNavigation() {\n  return {\n    startNavigation: navigationManager.startNavigation.bind(navigationManager),\n    stopNavigation: navigationManager.stopNavigation.bind(navigationManager),\n    pauseNavigation: navigationManager.pauseNavigation.bind(navigationManager),\n    resumeNavigation: navigationManager.resumeNavigation.bind(navigationManager),\n    getState: navigationManager.getState.bind(navigationManager),\n    getCurrentInstruction: navigationManager.getCurrentInstruction.bind(navigationManager),\n    getUpcomingInstructions: navigationManager.getUpcomingInstructions.bind(navigationManager),\n    updateSettings: navigationManager.updateSettings.bind(navigationManager),\n    getSettings: navigationManager.getSettings.bind(navigationManager),\n    subscribe: (event: string, callback: Function) => {\n      navigationManager.on(event, callback);\n      return () => navigationManager.off(event, callback);\n    }\n  };\n}","import type { LatLng, Route, Place } from '@/types';\nimport { EventBus } from '@/lib/utils/events';\nimport { themeProvider } from '@/core/theme/ThemeProvider';\nimport { telemetry } from '@/lib/telemetry';\nimport * as L from 'leaflet';\n\ninterface MapConfig {\n  providers: any;\n  center?: LatLng;\n  zoom?: number;\n}\n\nexport class MapManager extends EventBus {\n  private map?: L.Map;\n  private config: MapConfig;\n  private layers = {\n    route: L.layerGroup(),\n    places: L.layerGroup(),\n    user: L.layerGroup()\n  };\n  private currentLocation?: LatLng;\n\n  constructor(config: MapConfig) {\n    super();\n    this.config = config;\n  }\n\n  async initialize(): Promise<void> {\n    const mapContainer = document.getElementById('map');\n    if (!mapContainer) {\n      throw new Error('Map container not found');\n    }\n\n    // Initialize Leaflet map\n    this.map = L.map(mapContainer, {\n      center: this.config.center || [32.0853, 34.7818], // Tel Aviv default\n      zoom: this.config.zoom || 13,\n      zoomControl: true,\n      attributionControl: true\n    });\n\n    // Add tile layer based on theme\n    this.updateMapTiles();\n\n    // Add layer groups\n    Object.values(this.layers).forEach(layer => {\n      layer.addTo(this.map!);\n    });\n\n    // Setup event handlers\n    this.setupMapEvents();\n\n    telemetry.track('map_initialized', {\n      center: this.config.center,\n      zoom: this.config.zoom\n    });\n  }\n\n  private updateMapTiles(): void {\n    if (!this.map) return;\n\n    // Remove existing tile layers\n    this.map.eachLayer(layer => {\n      if (layer instanceof L.TileLayer) {\n        this.map!.removeLayer(layer);\n      }\n    });\n\n    // Add new tile layer based on theme\n    const tileLayer = L.tileLayer(themeProvider.getMapTileURL(), {\n      attribution: themeProvider.getMapTileAttribution(),\n      maxZoom: 19\n    });\n\n    tileLayer.addTo(this.map);\n  }\n\n  private setupMapEvents(): void {\n    if (!this.map) return;\n\n    this.map.on('click', (e) => {\n      this.emit('map-clicked', { location: e.latlng });\n      telemetry.track('map_clicked', {\n        lat: e.latlng.lat,\n        lng: e.latlng.lng,\n        zoom: this.map!.getZoom()\n      });\n    });\n\n    this.map.on('zoomend', () => {\n      this.emit('zoom-changed', { zoom: this.map!.getZoom() });\n    });\n\n    this.map.on('moveend', () => {\n      const center = this.map!.getCenter();\n      this.emit('center-changed', { center });\n    });\n  }\n\n  updateTheme(theme: 'light' | 'dark'): void {\n    this.updateMapTiles();\n    telemetry.track('map_theme_updated', { theme });\n  }\n\n  setCenter(location: LatLng, zoom?: number): void {\n    if (!this.map) return;\n    \n    this.map.setView([location.lat, location.lng], zoom || this.map.getZoom());\n    this.emit('center-changed', { center: location });\n  }\n\n  addPlace(place: Place, options: { showPopup?: boolean; focus?: boolean } = {}): L.Marker {\n    if (!this.map) throw new Error('Map not initialized');\n\n    const marker = L.marker([place.location.lat, place.location.lng])\n      .bindPopup(`\n        <div class=\"place-popup\">\n          <h3>${place.name}</h3>\n          ${place.address ? `<p>${place.address}</p>` : ''}\n          ${place.rating ? `<div>⭐ ${place.rating} (${place.userRatingsTotal || 0} reviews)</div>` : ''}\n          <div class=\"popup-actions\">\n            <button onclick=\"window.mapManager.focusPlace('${place.id}')\">Details</button>\n            <button onclick=\"window.mapManager.navigateToPlace('${place.id}')\">Navigate</button>\n          </div>\n        </div>\n      `);\n\n    marker.addTo(this.layers.places);\n\n    if (options.showPopup) {\n      marker.openPopup();\n    }\n\n    if (options.focus) {\n      this.setCenter(place.location, 16);\n    }\n\n    telemetry.track('place_added_to_map', {\n      place_id: place.id,\n      show_popup: options.showPopup,\n      focus: options.focus\n    });\n\n    return marker;\n  }\n\n  addRoute(route: Route, options: { color?: string; weight?: number } = {}): L.Polyline {\n    if (!this.map) throw new Error('Map not initialized');\n\n    // Decode polyline and create Leaflet polyline\n    const coordinates = this.decodePolyline(route.overview.polyline);\n    const polyline = L.polyline(coordinates, {\n      color: options.color || '#3b82f6',\n      weight: options.weight || 5,\n      opacity: 0.8\n    });\n\n    polyline.addTo(this.layers.route);\n\n    // Add markers for start and end\n    if (route.legs.length > 0) {\n      const firstLeg = route.legs[0];\n      const lastLeg = route.legs[route.legs.length - 1];\n\n      L.marker([firstLeg.start.lat, firstLeg.start.lng])\n        .bindPopup('Start')\n        .addTo(this.layers.route);\n\n      L.marker([lastLeg.end.lat, lastLeg.end.lng])\n        .bindPopup('Destination')\n        .addTo(this.layers.route);\n    }\n\n    // Fit map to route bounds\n    this.map.fitBounds(polyline.getBounds(), { padding: [20, 20] });\n\n    telemetry.track('route_added_to_map', {\n      distance: route.overview.distance,\n      duration: route.overview.duration,\n      legs_count: route.legs.length\n    });\n\n    return polyline;\n  }\n\n  setUserLocation(location: LatLng, accuracy?: number): void {\n    if (!this.map) return;\n\n    this.currentLocation = location;\n\n    // Clear existing user location markers\n    this.layers.user.clearLayers();\n\n    // Add user location marker\n    const userMarker = L.marker([location.lat, location.lng], {\n      icon: L.divIcon({\n        className: 'user-location-marker',\n        html: '<div class=\"user-location-dot\"></div>',\n        iconSize: [20, 20],\n        iconAnchor: [10, 10]\n      })\n    }).bindPopup('Your location');\n\n    userMarker.addTo(this.layers.user);\n\n    // Add accuracy circle if provided\n    if (accuracy) {\n      const accuracyCircle = L.circle([location.lat, location.lng], {\n        radius: accuracy,\n        weight: 1,\n        color: '#3b82f6',\n        fillColor: '#3b82f6',\n        fillOpacity: 0.1\n      });\n\n      accuracyCircle.addTo(this.layers.user);\n    }\n\n    this.emit('user-location-updated', { location, accuracy });\n  }\n\n  getCurrentLocation(): LatLng | undefined {\n    return this.currentLocation;\n  }\n\n  clearPlaces(): void {\n    this.layers.places.clearLayers();\n  }\n\n  clearRoute(): void {\n    this.layers.route.clearLayers();\n  }\n\n  clearAll(): void {\n    Object.values(this.layers).forEach(layer => layer.clearLayers());\n  }\n\n  focusPlace(placeId: string): void {\n    // Implementation would focus on a specific place\n    this.emit('place-focused', { placeId });\n  }\n\n  navigateToPlace(placeId: string): void {\n    // Implementation would start navigation to place\n    this.emit('navigation-requested', { placeId });\n  }\n\n  // Utility method to decode Google polyline\n  private decodePolyline(encoded: string): [number, number][] {\n    const poly: [number, number][] = [];\n    let index = 0;\n    const len = encoded.length;\n    let lat = 0;\n    let lng = 0;\n\n    while (index < len) {\n      let b: number;\n      let shift = 0;\n      let result = 0;\n\n      do {\n        b = encoded.charCodeAt(index++) - 63;\n        result |= (b & 0x1f) << shift;\n        shift += 5;\n      } while (b >= 0x20);\n\n      const dlat = ((result & 1) !== 0 ? ~(result >> 1) : (result >> 1));\n      lat += dlat;\n\n      shift = 0;\n      result = 0;\n\n      do {\n        b = encoded.charCodeAt(index++) - 63;\n        result |= (b & 0x1f) << shift;\n        shift += 5;\n      } while (b >= 0x20);\n\n      const dlng = ((result & 1) !== 0 ? ~(result >> 1) : (result >> 1));\n      lng += dlng;\n\n      poly.push([lat / 1e5, lng / 1e5]);\n    }\n\n    return poly;\n  }\n\n  destroy(): void {\n    if (this.map) {\n      this.map.remove();\n      this.map = undefined;\n    }\n    super.destroy();\n  }\n}\n\n// Global reference for popup callbacks\nif (typeof window !== 'undefined') {\n  (window as any).mapManager = {\n    focusPlace: (placeId: string) => {\n      // Global event for place focus\n      window.dispatchEvent(new CustomEvent('place-focus', { detail: { placeId } }));\n    },\n    navigateToPlace: (placeId: string) => {\n      // Global event for navigation request\n      window.dispatchEvent(new CustomEvent('navigation-request', { detail: { placeId } }));\n    }\n  };\n}","import type { VoiceIntent, UpdateInfo, Place, Route, TripPlan } from '@/types';\nimport { EventBus } from '@/lib/utils/events';\nimport { telemetry } from '@/lib/telemetry';\n\ninterface UIConfig {\n  planningManager: any;\n  voiceManager: any;\n  navigationManager: any;\n  aiOrchestrator: any;\n  providers: any;\n}\n\nexport class UIManager extends EventBus {\n  private config: UIConfig;\n  private isInitialized = false;\n  private currentView = 'search';\n\n  constructor(config: UIConfig) {\n    super();\n    this.config = config;\n  }\n\n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    this.setupNavigation();\n    this.setupVoiceUI();\n    this.setupPlanningUI();\n    this.setupSearchUI();\n    this.setupUpdateUI();\n    this.setupThemeToggle();\n\n    this.isInitialized = true;\n    telemetry.track('ui_manager_initialized');\n  }\n\n  private setupNavigation(): void {\n    // Support both nav-item and nav-btn classes for compatibility\n    const navItems = document.querySelectorAll('.nav-item, .nav-btn');\n    const views = document.querySelectorAll('.mobile-view, .app-view');\n\n    navItems.forEach(item => {\n      item.addEventListener('click', () => {\n        const targetView = item.getAttribute('data-view');\n        if (!targetView) return;\n\n        // Update navigation\n        navItems.forEach(nav => nav.classList.remove('active'));\n        item.classList.add('active');\n\n        // Update views\n        views.forEach(view => view.classList.remove('active'));\n        const targetElement = document.querySelector(`[data-view=\"${targetView}\"]`);\n        if (targetElement) {\n          targetElement.classList.add('active');\n        }\n\n        this.currentView = targetView;\n        this.emit('view-changed', { view: targetView });\n        telemetry.track('view_changed', { view: targetView });\n\n        // Handle view-specific initialization\n        this.handleViewChange(targetView);\n      });\n    });\n  }\n\n  private handleViewChange(view: string): void {\n    switch (view) {\n      case 'map':\n        this.emit('map-view-activated');\n        break;\n      case 'trip':\n        this.initializeTripPlanning();\n        break;\n      case 'ai':\n        this.initializeAIInterface();\n        break;\n      case 'voice':\n        this.initializeVoiceInterface();\n        break;\n    }\n  }\n\n  private setupVoiceUI(): void {\n    const voiceBtn = document.getElementById('voiceBtn');\n    if (!voiceBtn) return;\n\n    let isHolding = false;\n\n    const startListening = async () => {\n      if (isHolding) return;\n      isHolding = true;\n      \n      try {\n        await this.config.voiceManager.startPressAndHold();\n        voiceBtn.classList.add('listening');\n        this.showVoiceStatus('Listening... Release to stop');\n        telemetry.track('voice_press_and_hold_started');\n      } catch (error) {\n        console.error('Voice listening failed:', error);\n        this.showVoiceStatus('Voice not available');\n        isHolding = false;\n      }\n    };\n\n    const stopListening = async () => {\n      if (!isHolding) return;\n      isHolding = false;\n\n      try {\n        await this.config.voiceManager.endPressAndHold();\n        voiceBtn.classList.remove('listening');\n        this.showVoiceStatus('Processing...');\n        telemetry.track('voice_press_and_hold_ended');\n      } catch (error) {\n        console.error('Voice stop failed:', error);\n        this.showVoiceStatus('');\n      }\n    };\n\n    // Mouse events\n    voiceBtn.addEventListener('mousedown', startListening);\n    voiceBtn.addEventListener('mouseup', stopListening);\n    voiceBtn.addEventListener('mouseleave', stopListening);\n\n    // Touch events\n    voiceBtn.addEventListener('touchstart', (e) => {\n      e.preventDefault();\n      startListening();\n    });\n    voiceBtn.addEventListener('touchend', (e) => {\n      e.preventDefault();\n      stopListening();\n    });\n    voiceBtn.addEventListener('touchcancel', stopListening);\n  }\n\n  private setupPlanningUI(): void {\n    // Duration selection\n    document.querySelectorAll('.duration-option').forEach(btn => {\n      btn.addEventListener('click', () => {\n        document.querySelectorAll('.duration-option').forEach(b => b.classList.remove('selected'));\n        btn.classList.add('selected');\n      });\n    });\n\n    // Interest selection\n    document.querySelectorAll('.interest-option').forEach(btn => {\n      btn.addEventListener('click', () => {\n        btn.classList.toggle('selected');\n        \n        // Limit to 4 selections\n        const selected = document.querySelectorAll('.interest-option.selected');\n        if (selected.length > 4) {\n          btn.classList.remove('selected');\n          this.showNotification('Maximum 4 interests allowed', 'warning');\n        }\n      });\n    });\n\n    // Budget slider\n    const budgetSlider = document.getElementById('budgetRange') as HTMLInputElement;\n    const budgetAmount = document.getElementById('budgetAmount');\n    if (budgetSlider && budgetAmount) {\n      budgetSlider.addEventListener('input', () => {\n        budgetAmount.textContent = budgetSlider.value;\n      });\n    }\n\n    // Generate trip button\n    const generateBtn = document.getElementById('generateTripBtn');\n    if (generateBtn) {\n      generateBtn.addEventListener('click', this.handleTripGeneration.bind(this));\n    }\n  }\n\n  private async handleTripGeneration(): Promise<void> {\n    const generateBtn = document.getElementById('generateTripBtn') as HTMLButtonElement;\n    const statusEl = document.getElementById('tripGenerationStatus');\n\n    if (!generateBtn || !statusEl) return;\n\n    generateBtn.disabled = true;\n    generateBtn.textContent = 'Generating...';\n    statusEl.textContent = 'Creating your perfect trip...';\n\n    try {\n      // Get form data\n      const duration = this.getSelectedDuration();\n      const interests = this.getSelectedInterests();\n      const budget = parseInt((document.getElementById('budgetRange') as HTMLInputElement)?.value || '300');\n      const groupType = (document.getElementById('groupType') as HTMLSelectElement)?.value || 'couple';\n      const groupSize = parseInt((document.getElementById('groupSize') as HTMLInputElement)?.value || '2');\n\n      // Create trip plan\n      const plan = await this.config.planningManager.createPlan(\n        'AI Generated Trip',\n        'Automatically generated based on your preferences'\n      );\n\n      // TODO: Use AI orchestrator to populate the plan\n      statusEl.textContent = 'Trip generated successfully!';\n      this.showTripPlan(plan);\n\n      telemetry.track('trip_generated', {\n        duration,\n        interests: interests.length,\n        budget,\n        group_type: groupType,\n        group_size: groupSize\n      });\n\n    } catch (error) {\n      console.error('Trip generation failed:', error);\n      statusEl.textContent = 'Failed to generate trip. Please try again.';\n      this.showError('Trip generation failed');\n    } finally {\n      generateBtn.disabled = false;\n      generateBtn.textContent = 'Generate Smart Trip';\n    }\n  }\n\n  private setupSearchUI(): void {\n    const searchBtn = document.getElementById('searchBtn');\n    const searchInput = document.getElementById('freeText') as HTMLInputElement;\n\n    if (searchBtn && searchInput) {\n      const performSearch = async () => {\n        const query = searchInput.value.trim();\n        if (!query) return;\n\n        try {\n          searchBtn.textContent = 'Searching...';\n          // TODO: Implement search via providers\n          this.showSearchResults([]);\n          telemetry.track('search_performed', { query });\n        } catch (error) {\n          console.error('Search failed:', error);\n          this.showError('Search failed');\n        } finally {\n          searchBtn.textContent = 'Search';\n        }\n      };\n\n      searchBtn.addEventListener('click', performSearch);\n      searchInput.addEventListener('keypress', (e) => {\n        if (e.key === 'Enter') performSearch();\n      });\n    }\n\n    // Quick search categories\n    document.querySelectorAll('.category-card').forEach(card => {\n      card.addEventListener('click', () => {\n        const preset = card.getAttribute('data-preset');\n        if (preset) {\n          this.performQuickSearch(preset);\n        }\n      });\n    });\n  }\n\n  private setupUpdateUI(): void {\n    // Create update notification container if it doesn't exist\n    if (!document.getElementById('updateNotification')) {\n      const container = document.createElement('div');\n      container.id = 'updateNotification';\n      container.className = 'update-notification hidden';\n      document.body.appendChild(container);\n    }\n  }\n\n  private setupThemeToggle(): void {\n    const themeToggle = document.getElementById('themeToggle');\n    if (!themeToggle) return;\n\n    themeToggle.addEventListener('click', () => {\n      // Theme toggle is handled by ThemeProvider\n      this.emit('theme-toggle-clicked');\n      telemetry.track('theme_toggle_clicked');\n    });\n  }\n\n  // Public methods\n  showUpdateNotification(updateInfo: UpdateInfo): void {\n    const container = document.getElementById('updateNotification');\n    if (!container) return;\n\n    container.innerHTML = `\n      <div class=\"update-card\">\n        <div class=\"update-header\">\n          <h3>🎉 Update Available</h3>\n          <button class=\"close-btn\" onclick=\"this.parentElement.parentElement.parentElement.classList.add('hidden')\">×</button>\n        </div>\n        <div class=\"update-content\">\n          <p>Version ${updateInfo.latest} is available</p>\n          ${updateInfo.urgent ? '<p class=\"urgent\">⚠️ Important security update</p>' : ''}\n          <div class=\"update-actions\">\n            <button class=\"btn-primary\" onclick=\"window.updateManager.applyUpdate()\">Update Now</button>\n            <button class=\"btn-secondary\" onclick=\"this.parentElement.parentElement.parentElement.classList.add('hidden')\">Later</button>\n          </div>\n        </div>\n      </div>\n    `;\n\n    container.classList.remove('hidden');\n    telemetry.track('update_notification_displayed', updateInfo);\n  }\n\n  showError(message: string): void {\n    this.showNotification(message, 'error');\n  }\n\n  showSuccess(message: string): void {\n    this.showNotification(message, 'success');\n  }\n\n  showNotification(message: string, type: 'info' | 'success' | 'warning' | 'error' = 'info'): void {\n    const notification = document.createElement('div');\n    notification.className = `notification notification-${type}`;\n    notification.textContent = message;\n\n    document.body.appendChild(notification);\n\n    // Auto remove after 3 seconds\n    setTimeout(() => {\n      notification.remove();\n    }, 3000);\n\n    telemetry.track('notification_shown', { message, type });\n  }\n\n  handleAIResult(intentType: string, result: any): void {\n    switch (intentType) {\n      case 'plan_create':\n        this.showTripPlan(result.plan);\n        break;\n      case 'search':\n        this.showSearchResults(result);\n        break;\n      case 'weather':\n        this.showWeatherInfo(result);\n        break;\n      default:\n        console.log('AI result:', result);\n    }\n  }\n\n  enterNavigationMode(): void {\n    document.body.classList.add('navigation-mode');\n    this.currentView = 'navigation';\n    this.emit('navigation-mode-entered');\n  }\n\n  exitNavigationMode(): void {\n    document.body.classList.remove('navigation-mode');\n    this.emit('navigation-mode-exited');\n  }\n\n  // Helper methods\n  private getSelectedDuration(): number {\n    const selected = document.querySelector('.duration-option.selected');\n    return parseInt(selected?.getAttribute('data-duration') || '8');\n  }\n\n  private getSelectedInterests(): string[] {\n    const selected = document.querySelectorAll('.interest-option.selected');\n    return Array.from(selected).map(el => el.getAttribute('data-interest')).filter(Boolean) as string[];\n  }\n\n  private showVoiceStatus(message: string): void {\n    const statusEl = document.getElementById('voiceStatus');\n    if (statusEl) {\n      statusEl.textContent = message;\n    }\n  }\n\n  private async performQuickSearch(category: string): Promise<void> {\n    try {\n      // TODO: Implement quick search\n      telemetry.track('quick_search_performed', { category });\n    } catch (error) {\n      console.error('Quick search failed:', error);\n      this.showError('Search failed');\n    }\n  }\n\n  private showTripPlan(plan: TripPlan): void {\n    const display = document.getElementById('enhancedTripDisplay');\n    if (display) {\n      display.hidden = false;\n      // TODO: Populate trip plan display\n    }\n  }\n\n  private showSearchResults(results: Place[]): void {\n    const listEl = document.getElementById('list');\n    if (!listEl) return;\n\n    if (results.length === 0) {\n      listEl.innerHTML = '<div class=\"no-results\">No results found</div>';\n      return;\n    }\n\n    listEl.innerHTML = results.map(place => `\n      <div class=\"result-card\">\n        <h3>${place.name}</h3>\n        <p>${place.address || ''}</p>\n        ${place.rating ? `<div class=\"rating\">⭐ ${place.rating}</div>` : ''}\n      </div>\n    `).join('');\n  }\n\n  private showWeatherInfo(weather: any): void {\n    // TODO: Display weather information\n    console.log('Weather info:', weather);\n  }\n\n  private initializeTripPlanning(): void {\n    // TODO: Initialize trip planning view\n  }\n\n  private initializeAIInterface(): void {\n    // TODO: Initialize AI interface\n  }\n\n  private initializeVoiceInterface(): void {\n    // TODO: Initialize voice interface\n  }\n}"],"names":["async","app","initialize","lightTheme","primary","secondary","background","surface","text","textSecondary","border","success","warning","error","darkTheme","EventBus","listeners","Map","on","event","callback","this","has","set","Set","get","add","off","eventListeners","delete","size","emit","data","forEach","console","once","wrapper","args","destroy","clear","themeProvider","currentTheme","prefersDark","mediaQuery","constructor","super","window","matchMedia","matches","addEventListener","e","applyTheme","theme","getEffectiveTheme","loadTheme","saved","localStorage","getItem","includes","saveTheme","setItem","getTheme","getColors","setTheme","toggleTheme","current","effective","colors","root","document","documentElement","Object","entries","key","value","style","setProperty","setAttribute","themeColorMeta","querySelector","content","updateMapStyle","dispatchEvent","CustomEvent","detail","getCSSVariables","vars","isDark","getMapTileURL","getMapTileAttribution","navigator","serviceWorker","type","updateManager","available","getLastUpdateInfo","latest","version","config","checkTimer","lastCheckTime","updateAvailable","latestVersion","checkInterval","apiEndpoint","currentVersion","autoCheck","startPeriodicCheck","checkForUpdates","force","now","Date","telemetry","track","response","fetch","cache","headers","Pragma","ok","Error","status","json","updateInfo","compareVersions","urgent","message","isNewerVersion","releaseNotes","breaking","length","latestParts","split","map","Number","currentParts","i","Math","max","latestPart","currentPart","applyUpdate","registration","getRegistration","waiting","postMessage","method","isNativeApp","redirectToStore","location","reload","ReactNativeWebView","webkit","messageHandlers","userAgent","open","setInterval","stopPeriodicCheck","clearInterval","OSRMProvider","baseUrl","profile","route","input","startTime","performance","getOSRMProfile","mode","coordString","origin","via","destination","coord","lng","lat","join","url","URL","searchParams","toString","AppError","routes","transformRoute","has_waypoints","duration","distance","overview","travel_time","osrmRoute","legs","leg","start","steps","intersections","end","step","instruction","maneuver","geometry","coordinates","polyline","encodePolyline","flatMap","bounds","calculateBounds","warnings","summary","lngs","lats","north","south","min","east","west","WeatherAwareRouter","routingProvider","weatherProvider","routeCache","weatherCache","cacheTimeout","calculateWeatherAwareRoute","options","basicRoute","getBasicRoute","weatherAware","originalRoute","weatherScore","weatherFactors","getNeutralWeatherFactors","recommendation","weatherAlerts","weatherAnalysis","analyzeRouteWeather","calculateWeatherScore","generateWeatherRecommendation","alternativeRoutes","includeAlternatives","overall","maxAlternatives","generateAlternativeRoutes","result","generateWeatherAlerts","weather_score","has_alternatives","cacheKey","JSON","stringify","cached","timestamp","weatherPromises","extractWeatherCheckpoints","getWeatherForPoint","point","Promise","all","checkpoints","push","midpoint","interpolateLatLng","toFixed","weather","getCurrent","weatherData","avgWeather","aggregateWeatherData","precipitation","scorePrecipitation","temperature","scoreTemperature","visibility","scoreVisibility","wind","scoreWind","windSpeed","count","reduce","sum","w","threshold","weatherThreshold","alerts","avgTemp","alternatives","alternativeOptions","routePreference","avoidHighways","avoidTolls","altOptions","slice","altRoute","routesSimilar","warn","sort","a","b","route1","route2","distanceDiff","abs","durationDiff","ratio","updateRouteWeather","getRouteForecast","departureTime","forecastData","getForecast","departureHour","getHours","relevantForecast","hourly","hourlyWeather","clearCache","PlannerAgent","placesProvider","createPlan","weatherContext","destinationPlaces","search","near","constraints","candidates","findCandidateStops","recommendations","scoreRecommendations","plan","createOptimizedItinerary","candidates_count","recommendations_count","weather_aware","reasoning","generatePlanReasoning","confidence","calculatePlanConfidence","categories","category","categoryPlaces","getCategorySearchTerm","radius","openNow","meal","scenic","activity","cultural","shopping","places","place","scores","rating","scoreRating","scoreDistance","scoreWeatherFit","priceLevel","scorePriceLevel","budget","score","generateRecommendationReasoning","inferCategory","estimatedDuration","estimateDuration","weatherFit","detourTime","calculateDistance","types","isIndoor","some","isOutdoor","currentWeather","estimatedCost","reasons","other","maxStops","selectedStops","name","description","stops","rec","index","id","priority","ceil","weatherDependent","notes","highRatedCount","filter","r","avgScore","hasHighQuality","from","to","φ1","PI","φ2","Δφ","Δλ","sin","cos","atan2","sqrt","AIOrchestrator","plannerAgent","initializeTools","tools","registerTool","execute","params","query","forecast","tool","processVoiceIntent","intent","context","intent_type","handlePlanCreate","handlePlanUpdate","handleSearch","handleNavigate","handleWeather","parameters","maxDrivingTime","userPreferences","action","explainRecommendation","userRatingsTotal","LocalStorageAdapter","item","parse","remove","removeItem","keys","IndexedDBAdapter","dbName","storeName","db","getDB","resolve","reject","request","indexedDB","onerror","onsuccess","onupgradeneeded","target","objectStoreNames","contains","createObjectStore","transaction","objectStore","put","getAllKeys","MemoryAdapter","Array","storage","adapter","createAdapter","getNumber","defaultValue","getString","getBoolean","getArray","isArray","getObject","setMany","items","getMany","acc","setWithTTL","ttlMs","expiry","getWithTTL","planningManager","currentPlan","plans","loadPlans","startDate","endDate","generateId","metadata","created","updated","savePlans","plan_id","has_description","duration_days","getTime","updatePlan","planId","updates","updatedPlan","validation","validatePlan","valid","errors","stops_count","has_route","deletePlan","addStop","stop","arrivalTime","insertIndex","splice","stop_id","has_timing","weather_dependent","updateStop","stopId","stopIndex","findIndex","s","updatedStop","removeStop","reorderStops","fromIndex","toIndex","movedStop","from_index","to_index","trim","stopPrefix","actualDuration","expectedDuration","nextStop","maxDuration","accommodation","fuel","totalDays","optimizeStopOrder","getPlan","getCurrentPlan","getAllPlans","values","setCurrentPlan","random","substr","currentPlanId","WebSpeechSTTProvider","recognition","isActive","eventBus","initializeRecognition","isSupported","SpeechRecognition","webkitSpeechRecognition","continuous","interimResults","lang","language","onstart","onend","onresult","results","transcript","transcript_length","is_final","isFinal","startListening","stopListening","isListening","SimpleLinguisticParser","patterns","plan_create","plan_update","navigate","normalizedTranscript","toLowerCase","intentType","pattern","match","extractParameters","original","captured","voiceManager","sttProvider","intentParser","isInitialized","setupEventHandlers","has_parameters","speak","utterance","SpeechSynthesisUtterance","rate","pitch","volume","text_length","speechSynthesis","stopSpeaking","cancel","isSpeaking","speaking","startPressAndHold","body","classList","endPressAndHold","processQuickCommand","command","navigationManager","state","isNavigating","currentLeg","currentStep","distanceToNextStep","estimatedTimeRemaining","settings","voiceGuidance","units","watchId","lastAnnouncedStep","loadSettings","startNavigation","startFromStep","currentRoute","startLocationTracking","total_distance","total_duration","legs_count","announceNextInstruction","stopNavigation","stopLocationTracking","was_completed","isNavigationComplete","pauseNavigation","resumeNavigation","geolocation","enableHighAccuracy","timeout","maximumAge","getCurrentPosition","position","updateLocation","coords","latitude","longitude","watchPosition","clearWatch","currentLocation","updateNavigationProgress","advanceToNextStep","updateEstimatedTime","checkVoiceAnnouncements","completeNavigation","completedLeg","total_legs","final_leg","final_step","remainingDistance","round","nextStepIndex","nextStep","formatDistance","meters","feet","getState","getCurrentInstruction","getUpcomingInstructions","upcoming","stepIndex","legIndex","updateSettings","newSettings","saveSettings","getSettings","simulateLocation","simulateProgress","MapManager","layers","L.layerGroup","user","mapContainer","getElementById","L.map","center","zoom","zoomControl","attributionControl","updateMapTiles","layer","addTo","setupMapEvents","eachLayer","L.TileLayer","removeLayer","L.tileLayer","attribution","maxZoom","latlng","getZoom","getCenter","updateTheme","setCenter","setView","addPlace","marker","L.marker","bindPopup","address","showPopup","openPopup","focus","place_id","show_popup","addRoute","decodePolyline","L.polyline","color","weight","opacity","firstLeg","lastLeg","fitBounds","getBounds","padding","setUserLocation","accuracy","clearLayers","icon","L.divIcon","className","html","iconSize","iconAnchor","L.circle","fillColor","fillOpacity","getCurrentLocation","clearPlaces","clearRoute","clearAll","focusPlace","placeId","navigateToPlace","encoded","poly","len","shift","charCodeAt","mapManager","UIManager","currentView","setupNavigation","setupVoiceUI","setupPlanningUI","setupSearchUI","setupUpdateUI","setupThemeToggle","navItems","querySelectorAll","views","targetView","getAttribute","nav","view","targetElement","handleViewChange","initializeTripPlanning","initializeAIInterface","initializeVoiceInterface","voiceBtn","isHolding","showVoiceStatus","preventDefault","btn","toggle","showNotification","budgetSlider","budgetAmount","textContent","generateBtn","handleTripGeneration","bind","statusEl","disabled","getSelectedDuration","interests","getSelectedInterests","parseInt","groupType","groupSize","showTripPlan","group_type","group_size","showError","searchBtn","searchInput","performSearch","showSearchResults","card","preset","performQuickSearch","container","createElement","appendChild","themeToggle","showUpdateNotification","innerHTML","showSuccess","notification","setTimeout","handleAIResult","showWeatherInfo","log","enterNavigationMode","exitNavigationMode","selected","el","Boolean","display","hidden","listEl","exports","providers","managers","aiOrchestrator","googleMapsApiKey","openWeatherApiKey","initializeTheme","initializeProviders","initializeManagers","initializeUI","googleProviders","createGoogleProviders","googlePlaces","googleRouting","routing","createOpenWeatherProvider","weatherAwareRouter","details","photos","ui","getUserPreferences","getProviders","getManagers","getAIOrchestrator","isReady"],"mappings":"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"}