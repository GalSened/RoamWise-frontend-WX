{"version":3,"file":"maps-COZuNwZo.js","sources":["../../src/lib/telemetry/index.ts","../../src/types/index.ts","../../src/providers/google/maps.ts"],"sourcesContent":["import type { TelemetryEvent, PerformanceMetric } from '@/types';\n\ninterface TelemetryConfig {\n  enabled: boolean;\n  endpoint?: string;\n  sessionId?: string;\n  userId?: string;\n  apiKey?: string;\n  batchSize?: number;\n  flushInterval?: number;\n}\n\nclass TelemetryManager {\n  private config: TelemetryConfig;\n  private eventQueue: TelemetryEvent[] = [];\n  private perfQueue: PerformanceMetric[] = [];\n  private flushTimer?: number;\n  private sessionId: string;\n\n  constructor(config: Partial<TelemetryConfig> = {}) {\n    this.config = {\n      enabled: import.meta.env.VITE_TELEMETRY_ENABLED === 'true',\n      endpoint: import.meta.env.VITE_TELEMETRY_ENDPOINT || '/api/telemetry',\n      batchSize: 10,\n      flushInterval: 30000, // 30 seconds\n      ...config\n    };\n\n    this.sessionId = this.generateSessionId();\n    \n    if (this.config.enabled) {\n      this.startPeriodicFlush();\n      this.setupUnloadHandler();\n      this.trackPageView();\n    }\n  }\n\n  track(eventName: string, properties?: Record<string, any>): void {\n    if (!this.config.enabled) return;\n\n    const event: TelemetryEvent = {\n      name: eventName,\n      properties: {\n        ...properties,\n        userAgent: navigator.userAgent,\n        url: window.location.href,\n        referrer: document.referrer\n      },\n      timestamp: Date.now(),\n      sessionId: this.sessionId,\n      userId: this.config.userId\n    };\n\n    this.eventQueue.push(event);\n    this.checkFlushThreshold();\n  }\n\n  trackPerformance(name: string, value: number, unit?: string): void {\n    if (!this.config.enabled) return;\n\n    const metric: PerformanceMetric = {\n      name,\n      value,\n      unit,\n      timestamp: Date.now()\n    };\n\n    this.perfQueue.push(metric);\n    this.checkFlushThreshold();\n  }\n\n  trackError(error: Error, context?: Record<string, any>): void {\n    if (!this.config.enabled) return;\n\n    this.track('error', {\n      message: error.message,\n      stack: error.stack,\n      name: error.name,\n      ...context\n    });\n  }\n\n  trackUserAction(action: string, target?: string, properties?: Record<string, any>): void {\n    if (!this.config.enabled) return;\n\n    this.track('user_action', {\n      action,\n      target,\n      ...properties\n    });\n  }\n\n  trackPageView(path?: string): void {\n    if (!this.config.enabled) return;\n\n    this.track('page_view', {\n      path: path || window.location.pathname,\n      title: document.title\n    });\n  }\n\n  measureTime<T>(name: string, fn: () => T | Promise<T>): T | Promise<T> {\n    if (!this.config.enabled) return fn();\n\n    const start = performance.now();\n    const result = fn();\n\n    if (result instanceof Promise) {\n      return result.finally(() => {\n        this.trackPerformance(name, performance.now() - start, 'ms');\n      }) as Promise<T>;\n    } else {\n      this.trackPerformance(name, performance.now() - start, 'ms');\n      return result;\n    }\n  }\n\n  setUser(userId: string): void {\n    this.config.userId = userId;\n  }\n\n  setProperty(key: string, value: any): void {\n    // Set global property for all future events\n    if (!(globalThis as any).__telemetryGlobals) {\n      (globalThis as any).__telemetryGlobals = {};\n    }\n    (globalThis as any).__telemetryGlobals[key] = value;\n  }\n\n  private generateSessionId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private startPeriodicFlush(): void {\n    this.flushTimer = window.setInterval(() => {\n      this.flush();\n    }, this.config.flushInterval);\n  }\n\n  private setupUnloadHandler(): void {\n    const handleUnload = () => {\n      this.flush(true); // Synchronous flush on unload\n    };\n\n    window.addEventListener('beforeunload', handleUnload);\n    window.addEventListener('visibilitychange', () => {\n      if (document.visibilityState === 'hidden') {\n        this.flush();\n      }\n    });\n  }\n\n  private checkFlushThreshold(): void {\n    const totalEvents = this.eventQueue.length + this.perfQueue.length;\n    if (totalEvents >= this.config.batchSize!) {\n      this.flush();\n    }\n  }\n\n  private async flush(synchronous = false): Promise<void> {\n    if (this.eventQueue.length === 0 && this.perfQueue.length === 0) {\n      return;\n    }\n\n    const events = [...this.eventQueue];\n    const metrics = [...this.perfQueue];\n    \n    // Clear queues\n    this.eventQueue = [];\n    this.perfQueue = [];\n\n    const payload = {\n      events: events.map(event => ({\n        ...event,\n        properties: {\n          ...event.properties,\n          ...(globalThis as any).__telemetryGlobals\n        }\n      })),\n      metrics,\n      sessionId: this.sessionId,\n      timestamp: Date.now()\n    };\n\n    try {\n      if (synchronous && 'sendBeacon' in navigator) {\n        // Use sendBeacon for reliable delivery during page unload\n        navigator.sendBeacon(\n          this.config.endpoint!,\n          JSON.stringify(payload)\n        );\n      } else {\n        await fetch(this.config.endpoint!, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...(this.config.apiKey && { 'Authorization': `Bearer ${this.config.apiKey}` })\n          },\n          body: JSON.stringify(payload),\n          keepalive: true\n        });\n      }\n    } catch (error) {\n      console.warn('Failed to send telemetry:', error);\n      // Re-queue events on failure (but limit to prevent infinite growth)\n      if (this.eventQueue.length < 100) {\n        this.eventQueue.unshift(...events.slice(-50));\n        this.perfQueue.unshift(...metrics.slice(-50));\n      }\n    }\n  }\n\n  destroy(): void {\n    if (this.flushTimer) {\n      clearInterval(this.flushTimer);\n    }\n    this.flush(true);\n  }\n}\n\n// Core Web Vitals tracking\nfunction trackWebVitals(): void {\n  if (!('PerformanceObserver' in window)) return;\n\n  try {\n    // Largest Contentful Paint\n    const lcpObserver = new PerformanceObserver((list) => {\n      const entries = list.getEntries();\n      const lastEntry = entries[entries.length - 1] as any;\n      if (lastEntry) {\n        telemetry.trackPerformance('lcp', lastEntry.startTime, 'ms');\n      }\n    });\n    lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });\n\n    // First Input Delay\n    const fidObserver = new PerformanceObserver((list) => {\n      const entries = list.getEntries();\n      entries.forEach((entry: any) => {\n        telemetry.trackPerformance('fid', entry.processingStart - entry.startTime, 'ms');\n      });\n    });\n    fidObserver.observe({ entryTypes: ['first-input'] });\n\n    // Cumulative Layout Shift\n    let clsValue = 0;\n    const clsObserver = new PerformanceObserver((list) => {\n      const entries = list.getEntries();\n      entries.forEach((entry: any) => {\n        if (!entry.hadRecentInput) {\n          clsValue += entry.value;\n        }\n      });\n    });\n    clsObserver.observe({ entryTypes: ['layout-shift'] });\n\n    // Send CLS on page hide\n    window.addEventListener('beforeunload', () => {\n      telemetry.trackPerformance('cls', clsValue);\n    });\n  } catch (error) {\n    console.warn('Web Vitals tracking failed:', error);\n  }\n}\n\n// Global telemetry instance\nexport const telemetry = new TelemetryManager();\n\n// Initialize Web Vitals tracking\nif (typeof window !== 'undefined') {\n  trackWebVitals();\n}\n\n// Export hook for easier usage\nexport function useTelemetry() {\n  return {\n    track: telemetry.track.bind(telemetry),\n    trackPerformance: telemetry.trackPerformance.bind(telemetry),\n    trackError: telemetry.trackError.bind(telemetry),\n    trackUserAction: telemetry.trackUserAction.bind(telemetry),\n    measureTime: telemetry.measureTime.bind(telemetry),\n    setUser: telemetry.setUser.bind(telemetry),\n    setProperty: telemetry.setProperty.bind(telemetry)\n  };\n}","// Core Types\nexport interface LatLng {\n  lat: number;\n  lng: number;\n}\n\nexport interface Bounds {\n  north: number;\n  south: number;\n  east: number;\n  west: number;\n}\n\n// Theme Types\nexport type Theme = 'light' | 'dark' | 'system';\n\nexport interface ThemeColors {\n  primary: string;\n  secondary: string;\n  background: string;\n  surface: string;\n  text: string;\n  textSecondary: string;\n  border: string;\n  success: string;\n  warning: string;\n  error: string;\n}\n\n// Place Types\nexport interface Place {\n  id: string;\n  name: string;\n  address?: string;\n  location: LatLng;\n  rating?: number;\n  userRatingsTotal?: number;\n  priceLevel?: number;\n  types?: string[];\n  openNow?: boolean;\n  photos?: PhotoRef[];\n  website?: string;\n  phoneNumber?: string;\n}\n\nexport interface PlaceDetail extends Place {\n  formattedAddress: string;\n  openingHours?: {\n    openNow: boolean;\n    periods: OpeningPeriod[];\n    weekdayText: string[];\n  };\n  reviews?: Review[];\n  vicinity?: string;\n}\n\nexport interface PhotoRef {\n  url: string;\n  width: number;\n  height: number;\n  attributions?: string[];\n}\n\nexport interface OpeningPeriod {\n  open: { day: number; time: string };\n  close?: { day: number; time: string };\n}\n\nexport interface Review {\n  author: string;\n  rating: number;\n  text: string;\n  time: number;\n}\n\n// Route Types\nexport interface Route {\n  legs: RouteLeg[];\n  overview: {\n    polyline: string;\n    bounds: Bounds;\n    duration: number;\n    distance: number;\n  };\n  warnings?: string[];\n  summary?: string;\n}\n\nexport interface RouteLeg {\n  start: LatLng;\n  end: LatLng;\n  duration: number;\n  distance: number;\n  steps: RouteStep[];\n  polyline: string;\n}\n\nexport interface RouteStep {\n  instruction: string;\n  duration: number;\n  distance: number;\n  start: LatLng;\n  end: LatLng;\n  polyline: string;\n  maneuver?: string;\n}\n\n// Weather Types\nexport interface WeatherNow {\n  temperature: number;\n  feelsLike: number;\n  humidity: number;\n  pressure: number;\n  visibility: number;\n  windSpeed: number;\n  windDirection: number;\n  precipitation: number;\n  cloudCover: number;\n  uvIndex: number;\n  condition: string;\n  icon: string;\n  isDaylight: boolean;\n}\n\nexport interface WeatherForecast {\n  hourly: WeatherHour[];\n  daily: WeatherDay[];\n}\n\nexport interface WeatherHour {\n  time: Date;\n  temperature: number;\n  precipitation: number;\n  windSpeed: number;\n  condition: string;\n  icon: string;\n}\n\nexport interface WeatherDay {\n  date: Date;\n  temperatureMax: number;\n  temperatureMin: number;\n  precipitation: number;\n  precipitationProbability: number;\n  windSpeed: number;\n  condition: string;\n  icon: string;\n  sunrise: Date;\n  sunset: Date;\n}\n\n// Trip Planning Types\nexport interface TripPlan {\n  id: string;\n  name: string;\n  description?: string;\n  startDate: Date;\n  endDate: Date;\n  stops: TripStop[];\n  route?: Route;\n  metadata: {\n    created: Date;\n    updated: Date;\n    version: number;\n  };\n}\n\nexport interface TripStop {\n  id: string;\n  place: Place;\n  arrivalTime?: Date;\n  departureTime?: Date;\n  duration?: number; // minutes\n  notes?: string;\n  category: StopCategory;\n  priority: number; // 1-5\n  weatherDependent?: boolean;\n}\n\nexport type StopCategory = \n  | 'meal'\n  | 'scenic'\n  | 'activity'\n  | 'accommodation'\n  | 'fuel'\n  | 'shopping'\n  | 'cultural'\n  | 'other';\n\n// AI Types\nexport interface PlanningConstraints {\n  maxDrivingTime?: number; // minutes\n  budget?: { min: number; max: number };\n  categories?: StopCategory[];\n  avoidTolls?: boolean;\n  weatherAware?: boolean;\n  accessibility?: boolean;\n  groupSize?: number;\n  hasChildren?: boolean;\n}\n\nexport interface AIRecommendation {\n  place: Place;\n  score: number;\n  reasoning: string;\n  category: StopCategory;\n  estimatedDuration: number;\n  weatherFit: number; // 0-1\n  detourTime: number; // minutes\n}\n\n// Voice Types\nexport interface VoiceIntent {\n  type: 'plan_create' | 'plan_update' | 'search' | 'navigate' | 'weather';\n  confidence: number;\n  parameters: Record<string, any>;\n  original: string;\n}\n\n// Provider Types\nexport interface RoutingProvider {\n  route(input: {\n    origin: LatLng;\n    destination: LatLng;\n    via?: LatLng[];\n    mode?: 'car' | 'bike' | 'walk';\n    avoidTolls?: boolean;\n    departTime?: Date;\n  }): Promise<Route>;\n}\n\nexport interface PlacesProvider {\n  search(\n    query: string,\n    options?: {\n      near?: LatLng;\n      type?: string;\n      openNow?: boolean;\n      radius?: number;\n    }\n  ): Promise<Place[]>;\n  details(placeId: string): Promise<PlaceDetail>;\n  photos(placeId: string, maxPhotos?: number): Promise<PhotoRef[]>;\n}\n\nexport interface WeatherProvider {\n  getCurrent(lat: number, lng: number): Promise<WeatherNow>;\n  getForecast(lat: number, lng: number, at?: Date): Promise<WeatherForecast>;\n}\n\n// Telemetry Types\nexport interface TelemetryEvent {\n  name: string;\n  properties?: Record<string, any>;\n  timestamp?: number;\n  sessionId?: string;\n  userId?: string;\n}\n\nexport interface PerformanceMetric {\n  name: string;\n  value: number;\n  unit?: string;\n  timestamp?: number;\n}\n\n// Error Types\nexport class AppError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public statusCode?: number,\n    public retryable = false\n  ) {\n    super(message);\n    this.name = 'AppError';\n  }\n}\n\n// Update Types\nexport interface AppVersion {\n  version: string;\n  buildDate: string;\n  features: string[];\n  fixes: string[];\n  breaking?: string[];\n}\n\nexport interface UpdateInfo {\n  available: boolean;\n  current: string;\n  latest: string;\n  releaseNotes?: AppVersion;\n  urgent?: boolean;\n}\n\n// Additional types for weather-aware routing\nexport interface WeatherData {\n  temperature: number;\n  conditions: string;\n  icon: string;\n  precipitation?: number;\n  windSpeed?: number;\n  humidity?: number;\n  pressure?: number;\n  visibility?: number;\n}\n\nexport interface RouteOptions {\n  mode?: 'car' | 'bike' | 'walk';\n  avoidTolls?: boolean;\n  avoidHighways?: boolean;\n  routePreference?: 'fastest' | 'shortest' | 'scenic';\n  departTime?: Date;\n  via?: LatLng[];\n}\n\n// Additional interfaces for the app","import type { \n  PlacesProvider, \n  RoutingProvider, \n  Place, \n  PlaceDetail, \n  PhotoRef, \n  Route, \n  LatLng \n} from '@/types';\nimport { AppError } from '@/types';\nimport { telemetry } from '@/lib/telemetry';\n\ninterface GoogleMapsConfig {\n  apiKey: string;\n  language?: string;\n  region?: string;\n}\n\n// Google Maps Places Provider\nexport class GooglePlacesProvider implements PlacesProvider {\n  private config: GoogleMapsConfig;\n  private service?: google.maps.places.PlacesService;\n\n  constructor(config: GoogleMapsConfig) {\n    this.config = config;\n    this.initializeService();\n  }\n\n  private async initializeService(): Promise<void> {\n    if (this.service) return;\n\n    // Load Google Maps JavaScript API if not already loaded\n    if (typeof google === 'undefined') {\n      await this.loadGoogleMapsAPI();\n    }\n\n    // Create a temporary div for PlacesService\n    const div = document.createElement('div');\n    this.service = new google.maps.places.PlacesService(div);\n  }\n\n  private loadGoogleMapsAPI(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (typeof google !== 'undefined') {\n        resolve();\n        return;\n      }\n\n      const script = document.createElement('script');\n      script.src = `https://maps.googleapis.com/maps/api/js?key=${this.config.apiKey}&libraries=places&language=${this.config.language || 'en'}`;\n      script.async = true;\n      script.defer = true;\n      \n      script.onload = () => resolve();\n      script.onerror = () => reject(new AppError('Failed to load Google Maps API', 'MAPS_API_LOAD_FAILED'));\n      \n      document.head.appendChild(script);\n    });\n  }\n\n  async search(\n    query: string, \n    options: {\n      near?: LatLng;\n      type?: string;\n      openNow?: boolean;\n      radius?: number;\n    } = {}\n  ): Promise<Place[]> {\n    const startTime = performance.now();\n    \n    try {\n      await this.initializeService();\n      \n      const request: google.maps.places.TextSearchRequest = {\n        query,\n        location: options.near ? new google.maps.LatLng(options.near.lat, options.near.lng) : undefined,\n        radius: options.radius || 5000,\n        type: options.type as any,\n        openNow: options.openNow\n      };\n\n      const results = await new Promise<google.maps.places.PlaceResult[]>((resolve, reject) => {\n        this.service!.textSearch(request, (results, status) => {\n          if (status === google.maps.places.PlacesServiceStatus.OK && results) {\n            resolve(results);\n          } else {\n            reject(new AppError(`Places search failed: ${status}`, 'PLACES_SEARCH_FAILED'));\n          }\n        });\n      });\n\n      const places = results.map(this.transformPlace).filter(Boolean) as Place[];\n      \n      telemetry.track('places_search', {\n        query,\n        results_count: places.length,\n        duration: performance.now() - startTime,\n        has_location: !!options.near\n      });\n\n      return places;\n    } catch (error) {\n      telemetry.track('places_search_error', {\n        query,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        duration: performance.now() - startTime\n      });\n      throw error;\n    }\n  }\n\n  async details(placeId: string): Promise<PlaceDetail> {\n    const startTime = performance.now();\n    \n    try {\n      await this.initializeService();\n\n      const request: google.maps.places.PlaceDetailsRequest = {\n        placeId,\n        fields: [\n          'place_id', 'name', 'formatted_address', 'geometry',\n          'rating', 'user_ratings_total', 'price_level', 'types',\n          'opening_hours', 'formatted_phone_number', 'website',\n          'reviews', 'photos', 'vicinity'\n        ]\n      };\n\n      const result = await new Promise<google.maps.places.PlaceResult>((resolve, reject) => {\n        this.service!.getDetails(request, (place, status) => {\n          if (status === google.maps.places.PlacesServiceStatus.OK && place) {\n            resolve(place);\n          } else {\n            reject(new AppError(`Place details failed: ${status}`, 'PLACE_DETAILS_FAILED'));\n          }\n        });\n      });\n\n      const placeDetail = this.transformPlaceDetail(result);\n      \n      telemetry.track('place_details', {\n        place_id: placeId,\n        duration: performance.now() - startTime\n      });\n\n      return placeDetail;\n    } catch (error) {\n      telemetry.track('place_details_error', {\n        place_id: placeId,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        duration: performance.now() - startTime\n      });\n      throw error;\n    }\n  }\n\n  async photos(placeId: string, maxPhotos = 5): Promise<PhotoRef[]> {\n    try {\n      const placeDetail = await this.details(placeId);\n      return placeDetail.photos?.slice(0, maxPhotos) || [];\n    } catch (error) {\n      console.warn('Failed to get place photos:', error);\n      return [];\n    }\n  }\n\n  private transformPlace(gPlace: google.maps.places.PlaceResult): Place | null {\n    if (!gPlace.place_id || !gPlace.name || !gPlace.geometry?.location) {\n      return null;\n    }\n\n    return {\n      id: gPlace.place_id,\n      name: gPlace.name,\n      address: gPlace.formatted_address,\n      location: {\n        lat: gPlace.geometry.location.lat(),\n        lng: gPlace.geometry.location.lng()\n      },\n      rating: gPlace.rating,\n      userRatingsTotal: gPlace.user_ratings_total,\n      priceLevel: gPlace.price_level,\n      types: gPlace.types,\n      openNow: gPlace.opening_hours?.open_now,\n      photos: gPlace.photos?.map(photo => ({\n        url: photo.getUrl({ maxWidth: 400, maxHeight: 300 }),\n        width: 400,\n        height: 300,\n        attributions: photo.html_attributions\n      }))\n    };\n  }\n\n  private transformPlaceDetail(gPlace: google.maps.places.PlaceResult): PlaceDetail {\n    const base = this.transformPlace(gPlace);\n    if (!base) {\n      throw new AppError('Invalid place data', 'INVALID_PLACE_DATA');\n    }\n\n    return {\n      ...base,\n      formattedAddress: gPlace.formatted_address || base.address || '',\n      phoneNumber: gPlace.formatted_phone_number,\n      website: gPlace.website,\n      openingHours: gPlace.opening_hours ? {\n        openNow: gPlace.opening_hours.open_now || false,\n        periods: gPlace.opening_hours.periods?.map(period => ({\n          open: {\n            day: period.open?.day || 0,\n            time: period.open?.time || '0000'\n          },\n          close: period.close ? {\n            day: period.close.day,\n            time: period.close.time\n          } : undefined\n        })) || [],\n        weekdayText: gPlace.opening_hours.weekday_text || []\n      } : undefined,\n      reviews: gPlace.reviews?.map(review => ({\n        author: review.author_name,\n        rating: review.rating,\n        text: review.text,\n        time: review.time\n      })),\n      vicinity: gPlace.vicinity\n    };\n  }\n}\n\n// Google Routes Provider\nexport class GoogleRoutesProvider implements RoutingProvider {\n  private config: GoogleMapsConfig;\n  private service?: google.maps.DirectionsService;\n\n  constructor(config: GoogleMapsConfig) {\n    this.config = config;\n    this.initializeService();\n  }\n\n  private async initializeService(): Promise<void> {\n    if (this.service) return;\n\n    if (typeof google === 'undefined') {\n      await this.loadGoogleMapsAPI();\n    }\n\n    this.service = new google.maps.DirectionsService();\n  }\n\n  private loadGoogleMapsAPI(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (typeof google !== 'undefined') {\n        resolve();\n        return;\n      }\n\n      const script = document.createElement('script');\n      script.src = `https://maps.googleapis.com/maps/api/js?key=${this.config.apiKey}&language=${this.config.language || 'en'}`;\n      script.async = true;\n      script.defer = true;\n      \n      script.onload = () => resolve();\n      script.onerror = () => reject(new AppError('Failed to load Google Maps API', 'MAPS_API_LOAD_FAILED'));\n      \n      document.head.appendChild(script);\n    });\n  }\n\n  async route(input: {\n    origin: LatLng;\n    destination: LatLng;\n    via?: LatLng[];\n    mode?: 'car' | 'bike' | 'walk';\n    avoidTolls?: boolean;\n    departTime?: Date;\n  }): Promise<Route> {\n    const startTime = performance.now();\n    \n    try {\n      await this.initializeService();\n\n      const request: google.maps.DirectionsRequest = {\n        origin: new google.maps.LatLng(input.origin.lat, input.origin.lng),\n        destination: new google.maps.LatLng(input.destination.lat, input.destination.lng),\n        waypoints: input.via?.map(point => ({\n          location: new google.maps.LatLng(point.lat, point.lng),\n          stopover: true\n        })),\n        travelMode: this.getTravelMode(input.mode || 'car'),\n        avoidTolls: input.avoidTolls || false,\n        drivingOptions: input.departTime ? {\n          departureTime: input.departTime,\n          trafficModel: google.maps.TrafficModel.BEST_GUESS\n        } : undefined,\n        unitSystem: google.maps.UnitSystem.METRIC\n      };\n\n      const result = await new Promise<google.maps.DirectionsResult>((resolve, reject) => {\n        this.service!.route(request, (result, status) => {\n          if (status === google.maps.DirectionsStatus.OK && result) {\n            resolve(result);\n          } else {\n            reject(new AppError(`Route calculation failed: ${status}`, 'ROUTE_CALCULATION_FAILED'));\n          }\n        });\n      });\n\n      const route = this.transformRoute(result);\n      \n      telemetry.track('route_calculation', {\n        mode: input.mode,\n        has_waypoints: !!(input.via?.length),\n        duration: performance.now() - startTime,\n        distance: route.overview.distance,\n        travel_time: route.overview.duration\n      });\n\n      return route;\n    } catch (error) {\n      telemetry.track('route_calculation_error', {\n        mode: input.mode,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        duration: performance.now() - startTime\n      });\n      throw error;\n    }\n  }\n\n  private getTravelMode(mode: string): google.maps.TravelMode {\n    switch (mode) {\n      case 'walk': return google.maps.TravelMode.WALKING;\n      case 'bike': return google.maps.TravelMode.BICYCLING;\n      case 'transit': return google.maps.TravelMode.TRANSIT;\n      default: return google.maps.TravelMode.DRIVING;\n    }\n  }\n\n  private transformRoute(gRoute: google.maps.DirectionsResult): Route {\n    const route = gRoute.routes[0];\n    if (!route) {\n      throw new AppError('No route found', 'NO_ROUTE_FOUND');\n    }\n\n    return {\n      legs: route.legs.map(leg => ({\n        start: {\n          lat: leg.start_location.lat(),\n          lng: leg.start_location.lng()\n        },\n        end: {\n          lat: leg.end_location.lat(),\n          lng: leg.end_location.lng()\n        },\n        duration: leg.duration?.value || 0,\n        distance: leg.distance?.value || 0,\n        steps: leg.steps.map(step => ({\n          instruction: step.instructions,\n          duration: step.duration?.value || 0,\n          distance: step.distance?.value || 0,\n          start: {\n            lat: step.start_location.lat(),\n            lng: step.start_location.lng()\n          },\n          end: {\n            lat: step.end_location.lat(),\n            lng: step.end_location.lng()\n          },\n          polyline: step.polyline?.points || '',\n          maneuver: step.maneuver\n        })),\n        polyline: leg.steps.map(step => step.polyline?.points).join('')\n      })),\n      overview: {\n        polyline: route.overview_polyline?.points || '',\n        bounds: {\n          north: route.bounds?.getNorthEast().lat() || 0,\n          south: route.bounds?.getSouthWest().lat() || 0,\n          east: route.bounds?.getNorthEast().lng() || 0,\n          west: route.bounds?.getSouthWest().lng() || 0\n        },\n        duration: route.legs.reduce((sum, leg) => sum + (leg.duration?.value || 0), 0),\n        distance: route.legs.reduce((sum, leg) => sum + (leg.distance?.value || 0), 0)\n      },\n      warnings: route.warnings,\n      summary: route.summary\n    };\n  }\n}\n\n// Factory function to create providers\nexport function createGoogleProviders(apiKey: string) {\n  const config = { apiKey, language: 'en', region: 'US' };\n  \n  return {\n    places: new GooglePlacesProvider(config),\n    routing: new GoogleRoutesProvider(config)\n  };\n}"],"names":["TelemetryManager","config","__publicField","eventName","properties","event","name","value","unit","metric","error","context","action","target","path","fn","start","result","userId","key","handleUnload","synchronous","events","metrics","payload","trackWebVitals","list","entries","lastEntry","telemetry","entry","clsValue","AppError","message","code","statusCode","retryable","GooglePlacesProvider","div","resolve","reject","script","query","options","startTime","request","places","results","status","placeId","place","placeDetail","maxPhotos","_a","gPlace","_b","_c","photo","base","period","review","GoogleRoutesProvider","input","point","route","mode","gRoute","_d","_e","leg","step","sum","createGoogleProviders","apiKey"],"mappings":"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"}